<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[ClassNotFoundException和NoClassDefFoundException]]></title>
    <url>%2FBlog%2F2019%2F01%2F31%2FClassException%2F</url>
    <content type="text"><![CDATA[简介 两异常跟java类加载相关 类加载时会先把编译好的类文件(.class或者jar包)加载到jvm方法区中，这个过程叫做加载，如果这个过程中没找类文件就会出现ClassNotFoundException 如果加载成功之后，jvm中会有一个该类的类对象(class对象),创建对象时就通过这个类对象，当在内存中没有找到这个类对象时就会出现NoClassDefFoundException ClassNotFoundException 这类异常出现在对类进行加载时，该路径下找不到对应的class文件。 比如通过Class.forName()加载类时没有找到class文件 比如通过类加载器ClassLoader加载loadClass()，或者findSystemClass()时没有找到class NotClassDefFoundError 这类错误发生在运行时 通常是编译通过，但当运行时使用new参数该类对象时，找不到类的定义造成 通常是由于一个类中引用了另外的一个类，而被引用的类没有被classLoader找到]]></content>
      <categories>
        <category>java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[js正则表达式]]></title>
    <url>%2FBlog%2F2019%2F01%2F29%2Fjs%E6%AD%A3%E5%88%99%2F</url>
    <content type="text"><![CDATA[js正则正则对象创建使用构造方式创建1var reg = new RegExp('abc','gi'); 第一个参数是正则内容，第二个参数是修饰符 修饰符通常有三种 i:表示忽略大小写匹配 g:表示全局匹配,即匹配到第一个之后不停止继续匹配 m:表示多行匹配,即遇到换行后不停止匹配，直到被匹配字符串结束 使用字面量方式创建1var reg = /abc/gi; 两个斜杠之间的是定义的正则内容 最后一个斜杠之后的是修饰符]]></content>
      <categories>
        <category>前端</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[List工具类]]></title>
    <url>%2FBlog%2F2019%2F01%2F24%2Flist%E5%B7%A5%E5%85%B7%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[list工具类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132public class ListUtil &#123; /** * 对list的元素按照多个属性名称排序, * @param list * @param isAsc true升序，false降序 * @param sortnameArr list元素的属性名称 */ public static &lt;E&gt; void sort(List&lt;E&gt; list, final boolean isAsc, final String... sortnameArr) &#123; Collections.sort(list, (a, b) -&gt; &#123; int ret = 0; try &#123; for (int i = 0; i &lt; sortnameArr.length; i++) &#123; ret = ListUtil.compareObject(sortnameArr[i], isAsc, a, b); if (0 != ret) &#123; break; &#125; &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return ret; &#125;); &#125; /** * 给list的每个属性都指定是升序还是降序 * * @param list * @param sortnameArr 参数数组 * @param typeArr 每个属性对应的升降序数组， true升序，false降序 */ public static &lt;E&gt; void sort(List&lt;E&gt; list, final String[] sortnameArr, final boolean[] typeArr) &#123; if (sortnameArr.length != typeArr.length) &#123; throw new RuntimeException("属性数组元素个数和升降序数组元素个数不相等"); &#125; Collections.sort(list, (a, b) -&gt; &#123; int ret = 0; try &#123; for (int i = 0; i &lt; sortnameArr.length; i++) &#123; ret = ListUtil.compareObject(sortnameArr[i], typeArr[i], a, b); if (0 != ret) &#123; break; &#125; &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return ret; &#125;); &#125; /** * 对2个对象按照指定属性名称进行排序 * * @param sortname 属性名称 * @param isAsc true升序，false降序 * @param a * @param b * @return * @throws Exception */ private static &lt;E&gt; int compareObject(final String sortname, final boolean isAsc, E a, E b) throws Exception &#123; int ret; Object value1 = ListUtil.forceGetFieldValue(a, sortname); Object value2 = ListUtil.forceGetFieldValue(b, sortname); String str1 = value1.toString(); String str2 = value2.toString(); if (value1 instanceof Number &amp;&amp; value2 instanceof Number) &#123; int maxlen = Math.max(str1.length(), str2.length()); str1 = ListUtil.addZero2Str((Number) value1, maxlen); str2 = ListUtil.addZero2Str((Number) value2, maxlen); &#125; else if (value1 instanceof Date &amp;&amp; value2 instanceof Date) &#123; long time1 = ((Date) value1).getTime(); long time2 = ((Date) value2).getTime(); int maxlen = Long.toString(Math.max(time1, time2)).length(); str1 = ListUtil.addZero2Str(time1, maxlen); str2 = ListUtil.addZero2Str(time2, maxlen); &#125; if (isAsc) &#123; ret = str1.compareTo(str2); &#125; else &#123; ret = str2.compareTo(str1); &#125; return ret; &#125; /** * 给数字对象按照指定长度在左侧补0. * &lt;p&gt; * 使用案例: addZero2Str(11,4) 返回 "0011", addZero2Str(-18,6)返回 "-000018" * * @param numObj 数字对象 * @param length 指定的长度 * @return */ public static String addZero2Str(Number numObj, int length) &#123; NumberFormat nf = NumberFormat.getInstance(); // 设置是否使用分组 nf.setGroupingUsed(false); // 设置最大整数位数 nf.setMaximumIntegerDigits(length); // 设置最小整数位数 nf.setMinimumIntegerDigits(length); return nf.format(numObj); &#125; /** * 获取指定对象的指定属性值（去除private,protected的限制） * * @param obj 属性名称所在的对象 * @param fieldName 属性名称 * @return * @throws Exception */ public static Object forceGetFieldValue(Object obj, String fieldName) throws Exception &#123; Field field = obj.getClass().getDeclaredField(fieldName); Object object = null; boolean accessible = field.isAccessible(); if (!accessible) &#123; // 如果是private,protected修饰的属性，需要修改为可以访问的 field.setAccessible(true); object = field.get(obj); // 还原private,protected属性的访问性质 field.setAccessible(accessible); return object; &#125; object = field.get(obj); return object; &#125;&#125;]]></content>
      <categories>
        <category>工具类</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[elasticsearch基础]]></title>
    <url>%2FBlog%2F2019%2F01%2F24%2Felasticsearch%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[elasticsearch123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736737738739740741742743744745746747748749750751752753754755756757758759760761762763764765766767768769770771772773774775776777778779780781782783784785786787788789790791792793794795796797798799800801802803804805806807808809810811812813814815816817818819820821822823824825826827828829830831832833834835836837838839840841842843844845846847848849850851852853854855856857858859860861862863864865866867868869870871872873874875876877878879880881882883884885886887888889890891892893894895896897898899900901902903904905906907908909910911912913914915916917918919920921922923924925926927928929930931932933934935936937938939940941942943944945946947948949950951952953954955956957958959960961962963964965966967968969970971972973974975976977978979980981982983984985986987988989990# 创建索引# 分片为3(一旦确定不能修改)# 备份为0PUT /lib/&#123; "settings":&#123; "index":&#123; "number_of_shards":3, "number_of_replicas":0 &#125; &#125;&#125;# 直接创建索引，使用默认的配置PUT lib2#查看索引的配置GET lib/_settingsGET lib2/_settings#查看所有索引的配置GET _all/_settings####添加文档#使用put生成指定id的文档#使用post生成自动生成id的文档PUT /lib/user/1&#123; "first_name":"Jane", "last_name":"Smith", "age":32, "about":"I like to collect rock albums", "interests":["music"]&#125;POST /lib/user/&#123; "first_name":"Douglas", "last_name":"Fir", "age":23, "about":"I like to build cabinets", "interests":["forestry"]&#125;#根据id获取文档GET /lib/user/1GET /lib/user/5iPaG2gBtKq2hhRQ9SLS#获取指定字段的值#根据id只获取age和about的值GET /lib/user/1?_source=age,about####更新文档#使用put方式根据id覆盖更新PUT /lib/user/1&#123; "first_name":"Jane", "last_name":"Smith", "age":36, "about":"I like to collect rock albums", "interests":["music"]&#125;#使用post方式更新指定字段POST /lib/user/1/_update&#123; "doc":&#123; "age":30 &#125;&#125;####删除#删除文档DELETE /lib/user/1#删除索引DELETE lib2####_mget批量获取GET /_mget&#123; "docs":[ &#123; "_index":"lib", "_type":"user", "_id":1 &#125;, &#123; "_index":"lib", "_type":"user", "_id":2 &#125;, &#123; "_index":"lib", "_type":"user", "_id":3 &#125; ]&#125;#指定字段的批量获取GET /_mget&#123; "docs":[ &#123; "_index":"lib", "_type":"user", "_id":1, "_source":"interests" &#125;, &#123; "_index":"lib", "_type":"user", "_id":2, "_source":["age","interests"] &#125; ]&#125;#获取的数据有相同点是可以简化GET /lib/user/_mget&#123; "docs":[ &#123; "_id":1, "_source":"interests" &#125;, &#123; "_id":2, "_source":["age","interests"] &#125; ]&#125;GET /lib/user/_mget&#123; "ids":["1","2","3"]&#125;####bulk批量操作#格式：#&#123;action:&#123;metadata&#125;&#125;\n#&#123;requestbode&#125;\n#action:#1.create:不存在时创建，存在时操作失败#2.index:不存在时创建，存在时替换#3.update:更新文档#4.delete:删除一个文档#metadata:指定索引、类型、id#批量添加POST /lib2/books/_bulk&#123;"index":&#123;"_id":1&#125;&#125;&#123;"title":"Java","price":55&#125;&#123;"index":&#123;"_id":2&#125;&#125;&#123;"title":"Html5","price":45&#125;&#123;"index":&#123;"_id":3&#125;&#125;&#123;"title":"Php","price":35&#125;&#123;"index":&#123;"_id":4&#125;&#125;&#123;"title":"Python","price":50&#125;#混合批量操作#混合批量操作时可以在每个操作中指定索引类型POST /lib2/books/_bulk&#123;"update":&#123;"_index":"lib2","_type":"books","_id":4&#125;&#125;&#123;"doc":&#123;"price":58&#125;&#125;&#123;"delete":&#123;"_index":"lib2","_type":"books","_id":4&#125;&#125;&#123;"create":&#123;"_index":"tt","_type":"ttt","_id":"100"&#125;&#125;&#123;"name":"lisi"&#125;&#123;"index":&#123;"_index":"tt","_type":"ttt"&#125;&#125;&#123;"name":"zhaosi"&#125;####版本控制#每次的文档操作都会使文档的版本_version增加1#内部版本控制时当传入的版本与库中版本一致时操作才会成功PUT /lib/user/1?version=18&#123; "first_name":"Jane", "last_name":"Smith", "age":32, "about":"I like to collect rock albums", "interests":["music"]&#125;#外部版本控制时传入的版本必须大于库中版本操作才会成功PUT /lib/user/1?version=28&amp;version_type=external&#123; "first_name":"Jane", "last_name":"Smith", "age":32, "about":"I like to collect rock albums", "interests":["music"]&#125;####mapping#添加文档时会自动添加字段的属性#true,false被设置为boolean类型#"afdfa"被设置为string类型#string类型分为text和keyword。text会分词建立索引，不能用来排序和聚合。keyword不能分词，可以用来过滤、排序和聚合#119等被设置为long类型#123.45等被设置为double类型#1990-12-12等被设置为date类型PUT /myindex/article/1&#123; "post_date":"2019-01-05", "title":"Java", "content":"java is the best language", "author_id":199&#125;#查看mappingGET /myindex/article/_mapping#手动常见mapping#index为false时设置此字段不会被索引PUT /lib6&#123; "mappings": &#123; "books":&#123; "properties":&#123; "title":&#123;"type":"text"&#125;, "name":&#123;"type":"text","analyzer":"standard"&#125;, "publish_date":&#123;"type":"date","index":false&#125;, "price":&#123;"type":"double"&#125;, "number":&#123;"type":"integer"&#125; &#125; &#125; &#125;&#125;####object类型PUT /lib5/person/1&#123; "name":"Tom", "age":25, "birthday":"1992-09-01", "address":&#123; "country":"china", "province":"shandong", "city":"qingdao" &#125;&#125;#上边文档对应的底层存储格式#&#123;# "name":["Tom"],# "age":[25],# "birthday":["1992-09-01"],# "address.country":["china"],# "address.province":["shandong"],# "address.city":["qingdao"]#&#125;#&#123;# "persons":[# &#123;"name":"lisi",age"27&#125;, # &#123;"name":"wangwu",age"26&#125;, # &#123;"name":"zhangsan",age"23&#125;, # ]#&#125;#上边文档对应的底层存储格式#&#123;# "persons.name":["lisi","wangwu","zhangsan"],# "persons.age":[27,26,23]#&#125;####基本查询#query查询分为term和match两类#数据准备PUT /lib3&#123; "settings": &#123; "number_of_shards": 3, "number_of_replicas": 0 &#125;, "mappings": &#123; "user":&#123; "properties":&#123; "name":&#123;"type":"text"&#125;, "address":&#123;"type":"text"&#125;, "age":&#123;"type":"integer"&#125;, "interests":&#123;"type":"text"&#125;, "birthday":&#123;"type":"date"&#125; &#125; &#125; &#125;&#125;PUT /lib3/user/1&#123; "name":"zhaoliu", "address":"hei long jiang sheng tie liu shi", "age":50, "birthday":"1970-12-12", "interests":"xi huan hejiu,duanlian,lvyou"&#125;PUT /lib3/user/2&#123; "name":"zhaoming", "address":"bei jing hai dian qu qing he zhen", "age":20, "birthday":"1998-10-12", "interests":"xi huan hejiu,duanlian,changge"&#125;PUT /lib3/user/3&#123; "name":"lisi", "address":"bei jing hai dian qu qing he zhen", "age":23, "birthday":"1998-10-12", "interests":"xi huan hejiu,duanlian,changge"&#125;PUT /lib3/user/4&#123; "name":"wangwu", "address":"bei jing hai dian qu qing he zhen", "age":26, "birthday":"1995-10-12", "interests":"xi huan biancheng,tingyinyue,lvyou"&#125;PUT /lib3/user/5&#123; "name":"zhagnsan", "address":"bei jing chao yang qu", "age":29, "birthday":"1998-10-12", "interests":"xi huan tingyinyue,changge,tiaowu"&#125;#简单查询GET /lib3/user/_search?q=name:lisiGET /lib3/user/_search?q=interests:changge&amp;sort=age:desc#term和terms查询#term和terms查询时不知道分词器的存在，即请求传入的查询条件不会被分词，直接在倒排索引中查找#适合数值、日期等不分词的查询#查询name中含有zhaoliu的GET /lib3/user/_search/&#123; "query":&#123; "term": &#123;"name": "zhaoliu"&#125; &#125;&#125;#terms指定多个属性GET /lib3/user/_search/&#123; "query":&#123; "terms": &#123; "interests": ["hejiu","changge"] &#125; &#125;&#125;#只取前两个GET /lib3/user/_search/&#123; "from": 0, "size": 2, "query":&#123; "terms": &#123; "interests": ["hejiu","changge"] &#125; &#125;&#125;#增加获取数据的属性信息，如versionGET /lib3/user/_search/&#123; "version": true, "query":&#123; "terms": &#123; "interests": ["hejiu","changge"] &#125; &#125;&#125;#match查询#match查询会分词，即请求传入的查询条件会先分词再在倒排索引中查询匹配GET /lib3/user/_search&#123; "query": &#123; "match": &#123; "name": "zhaoliu,zhaoming" &#125; &#125;&#125;#match_all查询所有GET /lib3/user/_search&#123; "query": &#123; "match_all": &#123;&#125; &#125;&#125;#multi_match可以指定多个字段GET /lib3/user/_search&#123; "query": &#123; "multi_match": &#123; "query": "changge", "fields": ["interests","name"] &#125; &#125;&#125;#match_phrase短语匹配，将请求的查询条件当做一个短语进行匹配，条件依据会分词，但是顺序不能错GET /lib3/user/_search&#123; "query": &#123; "match_phrase": &#123; "interests": "changge,duanlian" &#125; &#125;&#125;#使用_source指定需要取出的字段GET /lib3/user/_search&#123; "_source": ["address","name"], "query": &#123; "match": &#123; "interests": "changge" &#125; &#125;&#125;#在includes和excludes确定需要取出的字段GET /lib3/user/_search&#123; "_source": &#123; "includes": ["name","address"], "excludes": ["age","birthday"] &#125;, "query": &#123; "match_all": &#123;&#125; &#125;&#125;#可是使用正则表达式GET /lib3/user/_search&#123; "_source": &#123; "includes": "addr*" &#125;, "query": &#123; "match_all": &#123;&#125; &#125;&#125;#使用sort进行排序GET /lib3/user/_search&#123; "query": &#123; "match_all": &#123;&#125; &#125;, "sort": [ &#123; "age": &#123; "order": "asc" &#125; &#125; ]&#125;#使用match_phrase_prefix进行短语前缀匹配GET /lib3/user/_search&#123; "query": &#123; "match_phrase_prefix": &#123; "name": "zhao" &#125; &#125;&#125;#使用range指定查询的范围GET /lib3/user/_search&#123; "query": &#123; "range": &#123; "birthday": &#123; "from": "1995-10-10", "to": "2019-01-05" &#125; &#125; &#125;&#125;#使用range指定范围查询时，使用是否包含上下边界的关键字GET /lib3/user/_search&#123; "query": &#123; "range": &#123; "age": &#123; "from": 20, "to": 25, "include_lower":true, "include_upper":false &#125; &#125; &#125;&#125;#使用wildcard可是使用通配符查询GET /lib3/user/_search&#123; "query": &#123; "wildcard": &#123; "name": "li?i" &#125; &#125;&#125;#使用fuzzy进行模糊查询，即请求查询条件分词中有些字母错误，也会模糊匹配出来GET /lib3/user/_search&#123; "query": &#123; "fuzzy": &#123; "interests": "chagge" &#125; &#125;&#125;#使用highlight高亮显示GET /lib3/user/_search&#123; "query": &#123; "match_all": &#123;&#125; &#125;, "highlight": &#123; "fields": &#123;"interests": &#123;&#125;&#125; &#125;&#125;####中文query查询(练习之前的查询功能)#数据准备PUT /lib4&#123; "settings": &#123; "number_of_shards": 3, "number_of_replicas": 0 &#125;, "mappings": &#123; "user":&#123; "properties":&#123; "name":&#123;"type":"text","analyzer":"ik_max_word"&#125;, "address":&#123;"type":"text","analyzer":"ik_max_word"&#125;, "age":&#123;"type":"integer"&#125;, "interests":&#123;"type":"text","analyzer":"ik_max_word"&#125;, "birthday":&#123;"type":"date"&#125; &#125; &#125; &#125;&#125;PUT /lib4/user/1&#123; "name":"赵六", "address":"黑龙江省铁岭", "age":50, "birthday":"1970-12-12", "interests":"喜欢喝酒,锻炼,说相声"&#125;PUT /lib4/user/2&#123; "name":"赵明", "address":"北京海淀区清河", "age":20, "birthday":"1998-10-12", "interests":"喜欢喝酒,锻炼,唱歌"&#125;PUT /lib4/user/3&#123; "name":"lisi", "address":"北京海淀区清河", "age":23, "birthday":"1998-10-12", "interests":"喜欢喝酒,锻炼,唱歌"&#125;PUT /lib4/user/4&#123; "name":"王五", "address":"北京海淀区清河", "age":26, "birthday":"1995-10-12", "interests":"喜欢编程,听音乐,旅游"&#125;PUT /lib4/user/5&#123; "name":"张三", "address":"北京海淀区清河", "age":29, "birthday":"1988-10-12", "interests":"喜欢摄影,听音乐,跳舞"&#125;GET /lib4/user/_search&#123; "query": &#123; "term": &#123; "name": &#123; "value": "赵" &#125; &#125; &#125;&#125;GET /lib4/user/_search&#123; "query": &#123; "terms": &#123; "interests": [ "喝酒", "唱歌" ] &#125; &#125;&#125;GET /lib4/user/_search&#123; "version": true, "query": &#123; "terms": &#123; "interests": [ "喝酒", "唱歌" ] &#125; &#125;&#125;GET /lib4/user/_search&#123; "query": &#123; "match": &#123; "name": "赵六" &#125; &#125;&#125;GET /lib4/user/_search&#123; "query": &#123; "match_all": &#123;&#125; &#125;&#125;GET /lib4/user/_search&#123; "query": &#123; "multi_match": &#123; "query": "唱歌", "fields": ["interests","name"] &#125; &#125;&#125;GET /lib4/user/_search&#123; "query": &#123; "match_phrase": &#123; "interests": "锻炼,说相声" &#125; &#125;&#125;GET /lib4/user/_search&#123; "query": &#123; "match_phrase_prefix": &#123; "name": "赵" &#125; &#125;&#125;GET /lib4/user/_search&#123; "_source": ["address","name"], "query": &#123; "match": &#123; "interests": "唱歌" &#125; &#125;&#125;GET /lib4/user/_search&#123; "_source": &#123; "includes": "addr*", "excludes":["name","bir*"] &#125;, "query": &#123; "match_all": &#123;&#125; &#125;&#125;GET /lib4/user/_search&#123; "query": &#123; "match_all": &#123;&#125; &#125;, "sort": [ &#123; "age": &#123; "order": "asc" &#125; &#125; ]&#125;GET /lib4/user/_search&#123; "query": &#123; "range": &#123; "birthday": &#123; "from": "1990-10-10", "to": "2019-01-05" &#125; &#125; &#125;&#125;GET /lib4/user/_search&#123; "query": &#123; "range": &#123; "age": &#123; "from": 20, "to": 25, "include_lower":true, "include_upper":false &#125; &#125; &#125;&#125;GET /lib4/user/_search&#123; "query": &#123; "wildcard": &#123; "name": &#123; "value": "赵*" &#125; &#125; &#125;&#125;GET /lib4/user/_search&#123; "query": &#123; "wildcard": &#123; "name": &#123; "value": "li?i" &#125; &#125; &#125;&#125;GET /lib4/user/_search&#123; "query": &#123; "fuzzy": &#123; "name": "赵" &#125; &#125;&#125;GET /lib4/user/_search&#123; "query": &#123; "fuzzy": &#123; "interests": &#123;"value": "喝酒"&#125; &#125; &#125;&#125;####filter查询#与query查询的区别在于，filter查询不计算相关性，可以缓存，别query查询快#数据准备POST /lib7/items/_bulk&#123;"index":&#123;"_id":1&#125;&#125;&#123;"price":40,"itemId":"ID100123"&#125;&#123;"index":&#123;"_id":2&#125;&#125;&#123;"price":50,"itemId":"ID100124"&#125;&#123;"index":&#123;"_id":3&#125;&#125;&#123;"price":25,"itemId":"ID100125"&#125;&#123;"index":&#123;"_id":4&#125;&#125;&#123;"price":30,"itemId":"ID100126"&#125;&#123;"index":&#123;"_id":5&#125;&#125;&#123;"price":null,"itemId":"ID100127"&#125;GET /lib7/items/_search&#123; "query": &#123; "bool": &#123; "filter": &#123; "term": &#123; "price": "40" &#125; &#125; &#125; &#125;&#125;GET /lib7/items/_search&#123; "query": &#123; "bool": &#123; "filter": &#123; "terms": &#123; "price": [ 25, 40 ] &#125; &#125; &#125; &#125;&#125;GET lib7/items/_search&#123; "query": &#123; "bool": &#123; "filter": &#123; "term": &#123; "itemId": "id100123" &#125; &#125; &#125; &#125;&#125;####bool查询#must相当于关系型数据库的and#should相当于关系型数据库的or#must_not相当于关系型数据库的notGET /lib7/items/_search&#123; "query": &#123; "bool": &#123; "should": [ &#123;"term": &#123;"price": 25&#125;&#125;, &#123;"term":&#123;"itemId":"id100123"&#125;&#125; ], "must_not":&#123; "term":&#123;"price":30&#125; &#125; &#125; &#125;&#125;GET /lib7/items/_search&#123; "query": &#123; "bool": &#123; "should": [ &#123;"term":&#123;"itemId": "id100123"&#125;&#125;, &#123; "bool": &#123; "must": [ &#123;"term":&#123;"itemId": "id100124"&#125;&#125;, &#123;"term":&#123;"price": 40&#125;&#125; ] &#125; &#125; ] &#125; &#125;&#125;#使用range查询范围GET /lib7/items/_search&#123; "query": &#123; "bool": &#123; "filter": &#123; "range": &#123; "price": &#123; "gt": 25, "lt": 50 &#125; &#125; &#125; &#125; &#125;&#125;#使用exists判断某字段是否存在GET /lib7/items/_search&#123; "query": &#123; "bool": &#123; "filter": &#123; "exists": &#123; "field": "price" &#125; &#125; &#125; &#125;&#125;####使用aggs进行聚合查询#使用size关键字可以数据不展示，只展示聚合的结果GET /lib7/items/_search&#123; "size": 0, "aggs": &#123; "price_of_sum": &#123; "sum": &#123; "field": "price" &#125; &#125; &#125;&#125;GET /lib7/items/_search&#123; "size": 0, "aggs": &#123; "price_of_max": &#123; "max": &#123; "field": "price" &#125; &#125; &#125;&#125;GET /lib7/items/_search&#123; "size": 0, "aggs": &#123; "price_of_min": &#123; "min": &#123; "field": "price" &#125; &#125; &#125;&#125;GET /lib7/items/_search&#123; "size": 0, "aggs": &#123; "price_of_avg": &#123; "avg": &#123; "field": "price" &#125; &#125; &#125;&#125;#使用cardinality求基数(不相同的数据的个数)GET /lib7/items/_search&#123; "size": 0, "aggs": &#123; "price_of_cardi": &#123; "cardinality": &#123; "field": "price" &#125; &#125; &#125;&#125;#在聚合中使用terms进行分组GET /lib7/items/_search&#123; "size": 0, "aggs": &#123; "price_of_group": &#123; "terms": &#123; "field": "price" &#125; &#125; &#125;&#125;#综合练习#对有唱歌兴趣的用户按年龄分组后求每一组的平均值并按倒序排序GET /lib3/user/_search&#123; "size": 0, "query": &#123; "match": &#123; "interests": "changge" &#125; &#125;, "aggs": &#123; "age_of_group":&#123; "terms": &#123; "field": "age", "order": &#123; "age_of_avg": "desc" &#125; &#125;, "aggs": &#123; "age_of_avg": &#123; "avg": &#123; "field": "age" &#125; &#125; &#125; &#125; &#125;&#125;####复合查询GET /lib3/user/_search&#123; "query": &#123; &#125;&#125;]]></content>
      <categories>
        <category>elasticsearch</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[swal]]></title>
    <url>%2FBlog%2F2018%2F12%2F27%2Fswal%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[123456789101112131415161718swal(&#123; title: "确认删除?", text: "Your will not be able to recover this imaginary file!", type: "warning", showCancelButton: true, confirmButtonColor: "#DD6B55", confirmButtonText: "确认", cancelButtonText: "取消", closeOnConfirm: false, closeOnCancel: false&#125;,function(isConfirm)&#123; if (isConfirm) &#123; swal("Deleted!", "Your imaginary file has been deleted.", "success"); &#125; else &#123; swal("Cancelled", "Your imaginary file is safe :)", "error"); &#125;&#125;);]]></content>
      <categories>
        <category>前端</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Servlet3.0新增特性]]></title>
    <url>%2FBlog%2F2018%2F12%2F22%2Fservlet3.0%2F</url>
    <content type="text"><![CDATA[简介 增加注解支持，使用@WebServlet @Filter @Listener等注解代替在web.xml中的配置 支持Web模块 增加Servlet异步处理 文件上传的API简化 注解 @WebServlet ：修饰Servlet类，代替web.xml中的配置 @WebFilter：修饰Filter类，代替web.xml中的配置 @WebInitParam：与@WebServlet或@WebFilter注解连用，为servlet设置初始化参数 @MultipartConfig：修饰Servlet类，指定该Servlet类负责处理multipart/form-data类型请求（文件上传的请求） @ServletSecurity：修饰Servlet类，与JAAS(Java验证和授权API)有关的注解 @HttpConstrait：与@ServletSecurity连用 @HttpMethodConstrait：与@ServletSecurity连用 代码@WebServlet(name = &quot;HelloServlet&quot;, urlPatterns = { &quot;/helloServlet&quot; }, loadOnStartup = 1, initParams = { @WebInitParam(name = &quot;userName&quot;, value = &quot;joseph&quot;), @WebInitParam(name = &quot;age&quot;, value = &quot;18&quot;) }) public class ServletAnnotation extends HttpServlet { String userName; String age; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws IOException { System.out.println(&quot;=======get test HelloServlet=======&quot;); resp.getOutputStream() .write((&quot;=======get test HelloServlet=======\n userName=&quot; + userName + &quot; age=&quot; + age).getBytes()); } @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws IOException { System.out.println(&quot;=======post test HelloServlet=======&quot;); resp.getOutputStream() .write((&quot;=======get test HelloServlet=======\n userName=&quot; + userName + &quot; age=&quot; + age).getBytes()); } } @WebListener public class ListenerAnnotation implements ServletRequestListener { @Override public void requestInitialized(ServletRequestEvent sre) { System.out.println(&quot;=======webListener======&quot;); } @Override public void requestDestroyed(ServletRequestEvent sre) { System.out.println(&quot;=======webListener======&quot;); } } @WebFilter(filterName = &quot;myFilter&quot;, urlPatterns = { &quot;/*&quot; }, initParams = { @WebInitParam(name = &quot;ref&quot;, value = &quot;test&quot;) }) public class FilterAnnotation implements Filter { // 初始化过滤器 @Override public void init(FilterConfig config) throws ServletException { // 取得初始化参数 String initParam = config.getInitParameter(&quot;ref&quot;); System.out.println(&quot;=========webfilter=======&quot;); System.out.println(&quot;** 过滤器初始化，初始化参数 = &quot; + initParam); } @Override public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException { System.out.println(&quot;** 执行doFilter()方法之前。&quot;); // 将请求继续传递 chain.doFilter(request, response); System.out.println(&quot;** 执行doFilter()方法之后。&quot;); } @Override public void destroy() { System.out.println(&quot;*========过滤器销毁=========&quot;); } }]]></content>
      <categories>
        <category>servlet</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[StringTokenizer]]></title>
    <url>%2FBlog%2F2018%2F12%2F22%2Fother%2F</url>
    <content type="text"><![CDATA[实践问题汇总情景业务上的审批操作允许的多个人审批，但对于每一个业务只能审批一次，即甲审批修改了状态之后乙就不能审批了，如何在程序中保证一条业务只能审批一次 方法直接想到的方法就是在进行审批更新之前，在数据库中查询是否已经修改，根据结果判断是否要执行更新操作，但此种方法由于数据库查询不是安全的，可能出现这条记录已经修改但是没有提交，此时的查询不能查询出未提交的状态，所以根据查询判断是不能保证只审批一次的。正确的做法是不进行查询，直接进行更新操作，更新的条件中增加上状态字段，由于更新操作会锁对应的记录，所以不会出现两次更新数据一致性问题，更新的结果就是只有一个更新操作会成功，另一个由于更新中的状态筛选条件而无法找到对应的数据而更新失败。]]></content>
      <categories>
        <category>other</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[循环标签]]></title>
    <url>%2FBlog%2F2018%2F12%2F13%2F%E5%BE%AA%E7%8E%AF%E6%A0%87%E7%AD%BE%2F</url>
    <content type="text"><![CDATA[12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061public static void normalContinue()&#123; System.out.println("------------非标签continue----------"); for (int i = 0; i &lt; 4; i++) &#123; System.out.println("外层循环" + i); for (int j = 0; j &lt; 4; j++) &#123; if(j==2)&#123; continue; &#125; System.out.println("内部循环" + j); &#125; System.out.println("*************"); &#125; System.out.println("------------非标签continue----------"); &#125; public static void normalBreak()&#123; System.out.println("------------非标签break----------"); for (int i = 0; i &lt; 4; i++) &#123; System.out.println("外层循环" + i); for (int j = 0; j &lt; 4; j++) &#123; if(j==2)&#123; break; &#125; System.out.println("内部循环" + j); &#125; System.out.println("*************"); &#125; System.out.println("------------非标签break----------"); &#125; //使用continue outer跳出内层循环的时候，外层循环后面的语句也不会执行 public static void labelContinue()&#123; System.out.println("------------标签continue----------"); outer: for (int i = 0; i &lt; 4; i++) &#123; System.out.println("外层循环" + i); for (int j = 0; j &lt; 4; j++) &#123; if(j==2)&#123; continue outer; &#125; System.out.println("内部循环" + j); &#125; System.out.println("*************"); &#125; System.out.println("------------标签continue----------"); &#125; //break+标签 直接把内外层循环一起break public static void labelBreak()&#123; System.out.println("------------标签break----------"); outer: for (int i = 0; i &lt; 4; i++) &#123; System.out.println("外层循环" + i); for (int j = 0; j &lt; 4; j++) &#123; if(j==2)&#123; break outer; &#125; System.out.println("内部循环" + j); &#125; System.out.println("*************"); &#125; System.out.println("------------标签break----------"); &#125;]]></content>
      <categories>
        <category>java se</category>
      </categories>
      <tags>
        <tag>class</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ftp工具类]]></title>
    <url>%2FBlog%2F2018%2F12%2F12%2Fftp%E5%B7%A5%E5%85%B7%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[public class FtpCli { private static final String DEFAULT_CHARSET = &quot;UTF-8&quot;; private static final int DEFAULT_TIMEOUT = 60 * 1000; private static final String DAILY_FILE_PATH = &quot;dailyFilePath&quot;; private final String host; private final int port; private final String username; private final String password; private FTPClient ftpClient; private volatile String ftpBasePath; private FtpCli(String host, String username, String password) { this(host, 21, username, password, DEFAULT_CHARSET); setTimeout(DEFAULT_TIMEOUT, DEFAULT_TIMEOUT, DEFAULT_TIMEOUT); } private FtpCli(String host, int port, String username, String password, String charset) { ftpClient = new FTPClient(); ftpClient.setControlEncoding(charset); this.host = StringUtils.isEmpty(host) ? &quot;localhost&quot; : host; this.port = (port &lt;= 0) ? 21 : port; this.username = StringUtils.isEmpty(username) ? &quot;anonymous&quot; : username; this.password = password; } /** * 创建默认的ftp客户端 * @param host 主机名或者ip地址 * @param username ftp用户名 * @param password ftp密码 */ public static FtpCli createFtpCli(String host, String username, String password) { return new FtpCli(host, username, password); } /** * 创建自定义属性的ftp客户端 * @param host 主机名或者ip地址 * @param port ftp端口 * @param username ftp用户名 * @param password ftp密码 * @param charset 字符集 */ public static FtpCli createFtpCli(String host, int port, String username, String password, String charset) { return new FtpCli(host, port, username, password, charset); } /** * 设置超时时间 * @param defaultTimeout 超时时间 * @param connectTimeout 超时时间 * @param dataTimeout 超时时间 */ public void setTimeout(int defaultTimeout, int connectTimeout, int dataTimeout) { ftpClient.setDefaultTimeout(defaultTimeout); ftpClient.setConnectTimeout(connectTimeout); ftpClient.setDataTimeout(dataTimeout); } /** * 连接到ftp */ public void connect() throws IOException { try { ftpClient.connect(host, port); } catch (UnknownHostException e) { throw new IOException(&quot;Can&apos;t find FTP server :&quot; + host); } int reply = ftpClient.getReplyCode(); if (!FTPReply.isPositiveCompletion(reply)) { disconnect(); throw new IOException(&quot;Can&apos;t connect to server :&quot; + host); } if (!ftpClient.login(username, password)) { disconnect(); throw new IOException(&quot;Can&apos;t login to server :&quot; + host); } // set data transfer mode. ftpClient.setFileType(FTP.BINARY_FILE_TYPE); // Use passive mode to pass firewalls. ftpClient.enterLocalPassiveMode(); initFtpBasePath(); } /** * 连接ftp时保存刚登陆ftp时的路径 */ private void initFtpBasePath() throws IOException { if (StringUtils.isEmpty(ftpBasePath)) { synchronized (this) { if (StringUtils.isEmpty(ftpBasePath)) { ftpBasePath = ftpClient.printWorkingDirectory(); } } } } /** * ftp是否处于连接状态，是连接状态返回&lt;tt&gt;true&lt;/tt&gt; * @return boolean 是连接状态返回&lt;tt&gt;true&lt;/tt&gt; */ public boolean isConnected() { return ftpClient.isConnected(); } /** * 上传文件到对应日期文件下， * 如当前时间是2018-06-06，则上传到[ftpBasePath]/[DAILY_FILE_PATH]/2018/06/06/下 * @param fileName 文件名 * @param inputStream 文件输入流 */ public String uploadFileToDailyDir(String fileName, InputStream inputStream) throws IOException { changeWorkingDirectory(ftpBasePath); SimpleDateFormat dateFormat = new SimpleDateFormat(&quot;/yyyy/MM/dd&quot;); String formatDatePath = dateFormat.format(new Date()); String uploadDir = DAILY_FILE_PATH + formatDatePath; makeDirs(uploadDir); storeFile(fileName, inputStream); return formatDatePath + &quot;/&quot; + fileName; } /** * 根据uploadFileToDailyDir返回的路径，从ftp下载文件到指定输出流中 * @param dailyDirFilePath 方法uploadFileToDailyDir返回的路径 * @param outputStream 输出流 */ public void downloadFileFromDailyDir(String dailyDirFilePath, OutputStream outputStream) throws IOException { changeWorkingDirectory(ftpBasePath); String ftpRealFilePath = dailyDirFilePath; ftpClient.retrieveFile(ftpRealFilePath, outputStream); } /** * 获取ftp上指定文件名到输出流中 * @param ftpFileName 文件在ftp上的路径 如绝对路径 /home/ftpuser/123.txt 或者相对路径 123.txt * @param out 输出流 */ public void retrieveFile(String ftpFileName, OutputStream out) throws IOException { try { FTPFile[] fileInfoArray = ftpClient.listFiles(ftpFileName); if (fileInfoArray == null || fileInfoArray.length == 0) { throw new FileNotFoundException(&quot;File &apos;&quot; + ftpFileName + &quot;&apos; was not found on FTP server.&quot;); } FTPFile fileInfo = fileInfoArray[0]; if (fileInfo.getSize() &gt; Integer.MAX_VALUE) { throw new IOException(&quot;File &apos;&quot; + ftpFileName + &quot;&apos; is too large.&quot;); } if (!ftpClient.retrieveFile(ftpFileName, out)) { throw new IOException( &quot;Error loading file &apos;&quot; + ftpFileName + &quot;&apos; from FTP server. Check FTP permissions and path.&quot;); } out.flush(); } finally { closeStream(out); } } /** * 将输入流存储到指定的ftp路径下 * @param ftpFileName 文件在ftp上的路径 如绝对路径 /home/ftpuser/123.txt 或者相对路径 123.txt * @param in 输入流 */ public void storeFile(String ftpFileName, InputStream in) throws IOException { try { if (!ftpClient.storeFile(ftpFileName, in)) { throw new IOException( &quot;Can&apos;t upload file &apos;&quot; + ftpFileName + &quot;&apos; to FTP server. Check FTP permissions and path.&quot;); } } finally { closeStream(in); } } /** * 根据文件ftp路径名称删除文件 * @param ftpFileName 文件ftp路径名称 */ public void deleteFile(String ftpFileName) throws IOException { if (!ftpClient.deleteFile(ftpFileName)) { throw new IOException(&quot;Can&apos;t remove file &apos;&quot; + ftpFileName + &quot;&apos; from FTP server.&quot;); } } /** * 上传文件到ftp * @param ftpFileName 上传到ftp文件路径名称 * @param localFile 本地文件路径名称 */ public void upload(String ftpFileName, File localFile) throws IOException { if (!localFile.exists()) { throw new IOException(&quot;Can&apos;t upload &apos;&quot; + localFile.getAbsolutePath() + &quot;&apos;. This file doesn&apos;t exist.&quot;); } InputStream in = null; try { in = new BufferedInputStream(new FileInputStream(localFile)); if (!ftpClient.storeFile(ftpFileName, in)) { throw new IOException( &quot;Can&apos;t upload file &apos;&quot; + ftpFileName + &quot;&apos; to FTP server. Check FTP permissions and path.&quot;); } } finally { closeStream(in); } } /** * 上传文件夹到ftp上 * @param remotePath ftp上文件夹路径名称 * @param localPath 本地上传的文件夹路径名称 */ public void uploadDir(String remotePath, String localPath) throws IOException { localPath = localPath.replace(&quot;\\\\&quot;, &quot;/&quot;); File file = new File(localPath); if (file.exists()) { if (!ftpClient.changeWorkingDirectory(remotePath)) { ftpClient.makeDirectory(remotePath); ftpClient.changeWorkingDirectory(remotePath); } File[] files = file.listFiles(); if (null != files) { for (File f : files) { if (f.isDirectory() &amp;&amp; !f.getName().equals(&quot;.&quot;) &amp;&amp; !f.getName().equals(&quot;..&quot;)) { uploadDir(remotePath + &quot;/&quot; + f.getName(), f.getPath()); } else if (f.isFile()) { upload(remotePath + &quot;/&quot; + f.getName(), f); } } } } } /** * 下载ftp文件到本地上 * @param ftpFileName ftp文件路径名称 * @param localFile 本地文件路径名称 */ public void download(String ftpFileName, File localFile) throws IOException { OutputStream out = null; try { FTPFile[] fileInfoArray = ftpClient.listFiles(ftpFileName); if (fileInfoArray == null || fileInfoArray.length == 0) { throw new FileNotFoundException(&quot;File &quot; + ftpFileName + &quot; was not found on FTP server.&quot;); } FTPFile fileInfo = fileInfoArray[0]; if (fileInfo.getSize() &gt; Integer.MAX_VALUE) { throw new IOException(&quot;File &quot; + ftpFileName + &quot; is too large.&quot;); } out = new BufferedOutputStream(new FileOutputStream(localFile)); if (!ftpClient.retrieveFile(ftpFileName, out)) { throw new IOException( &quot;Error loading file &quot; + ftpFileName + &quot; from FTP server. Check FTP permissions and path.&quot;); } out.flush(); } finally { closeStream(out); } } /** * 改变工作目录 * @param dir ftp服务器上目录 * @return boolean 改变成功返回true */ public boolean changeWorkingDirectory(String dir) { if (!ftpClient.isConnected()) { return false; } try { return ftpClient.changeWorkingDirectory(dir); } catch (IOException e) { } return false; } /** * 下载ftp服务器下文件夹到本地 * @param remotePath ftp上文件夹路径名称 * @param localPath 本地上传的文件夹路径名称 */ public void downloadDir(String remotePath, String localPath) throws IOException { localPath = localPath.replace(&quot;\\\\&quot;, &quot;/&quot;); File file = new File(localPath); if (!file.exists()) { file.mkdirs(); } FTPFile[] ftpFiles = ftpClient.listFiles(remotePath); for (int i = 0; ftpFiles != null &amp;&amp; i &lt; ftpFiles.length; i++) { FTPFile ftpFile = ftpFiles[i]; if (ftpFile.isDirectory() &amp;&amp; !ftpFile.getName().equals(&quot;.&quot;) &amp;&amp; !ftpFile.getName().equals(&quot;..&quot;)) { downloadDir(remotePath + &quot;/&quot; + ftpFile.getName(), localPath + &quot;/&quot; + ftpFile.getName()); } else { download(remotePath + &quot;/&quot; + ftpFile.getName(), new File(localPath + &quot;/&quot; + ftpFile.getName())); } } } /** * 列出ftp上文件目录下的文件 * @param filePath ftp上文件目录 */ public List&lt;String&gt; listFileNames(String filePath) throws IOException { FTPFile[] ftpFiles = ftpClient.listFiles(filePath); List&lt;String&gt; fileList = new ArrayList&lt;&gt;(); if (ftpFiles != null) { for (int i = 0; i &lt; ftpFiles.length; i++) { FTPFile ftpFile = ftpFiles[i]; if (ftpFile.isFile()) { fileList.add(ftpFile.getName()); } } } return fileList; } /** * 发送ftp命令到ftp服务器中 * @param args ftp命令 */ public void sendSiteCommand(String args) throws IOException { if (!ftpClient.isConnected()) { ftpClient.sendSiteCommand(args); } } /** * 获取当前所处的工作目录 */ public String printWorkingDirectory() { if (!ftpClient.isConnected()) { return &quot;&quot;; } try { return ftpClient.printWorkingDirectory(); } catch (IOException e) { // do nothing } return &quot;&quot;; } /** * 切换到当前工作目录的父目录下 */ public boolean changeToParentDirectory() { if (!ftpClient.isConnected()) { return false; } try { return ftpClient.changeToParentDirectory(); } catch (IOException e) { // do nothing } return false; } /** * 返回当前工作目录的上一级目录 */ public String printParentDirectory() { if (!ftpClient.isConnected()) { return &quot;&quot;; } String w = printWorkingDirectory(); changeToParentDirectory(); String p = printWorkingDirectory(); changeWorkingDirectory(w); return p; } /** * 创建目录 * @param pathname 路径名 */ public boolean makeDirectory(String pathname) throws IOException { return ftpClient.makeDirectory(pathname); } /** * 创建多个目录 */ public void makeDirs(String pathname) throws IOException { pathname = pathname.replace(&quot;\\\\&quot;, &quot;/&quot;); String[] pathnameArray = pathname.split(&quot;/&quot;); for (String each : pathnameArray) { if (StringUtils.isNotEmpty(each)) { ftpClient.makeDirectory(each); ftpClient.changeWorkingDirectory(each); } } } /** * 关闭流 */ private static void closeStream(Closeable stream) { if (stream != null) { try { stream.close(); } catch (IOException ex) { // do nothing } } } /** * 关闭ftp连接 */ public void disconnect() { if (null != ftpClient &amp;&amp; ftpClient.isConnected()) { try { ftpClient.logout(); ftpClient.disconnect(); } catch (IOException ex) { // do nothing } } } public static void main(String[] arg) throws IOException { FtpCli ftpCli = FtpCli.createFtpCli(&quot;192.168.191.70&quot;, &quot;administrator&quot;, &quot;admin&quot;); ftpCli.connect(); ftpCli.download(&quot;123/test.txt&quot;,new File(&quot;d:/test1.txt&quot;)); } }]]></content>
      <categories>
        <category>java ee</category>
      </categories>
      <tags>
        <tag>ftp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jep转换和计算数学表达式]]></title>
    <url>%2FBlog%2F2018%2F12%2F10%2Fjep%2F</url>
    <content type="text"><![CDATA[引入maven依赖&lt;dependency&gt; &lt;groupId&gt;jep&lt;/groupId&gt; &lt;artifactId&gt;jep&lt;/artifactId&gt; &lt;version&gt;2.24&lt;/version&gt; &lt;/dependency&gt; 代码JEP jep = new JEP(); //设置公式 String expression = &quot;((a+b)*(c+b))/(c+a)/b&quot;; //变量赋值 jep.addVariable(&quot;a&quot;,10); jep.addVariable(&quot;b&quot;,10); jep.addVariable(&quot;c&quot;,10); //运算 jep.parseExpression(expression); //结果 System.out.println(jep.getValue());]]></content>
      <categories>
        <category>java se</category>
      </categories>
      <tags>
        <tag>class</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RestController]]></title>
    <url>%2FBlog%2F2018%2F12%2F04%2FRestController%2F</url>
    <content type="text"><![CDATA[简介 此注解继承自controller，增加的responsebody注解 集合的controller和responsebody的作用，直接返回数据，不走视图解析器 代码@RestController @RequestMapping(&quot;/RestController&quot;) public class RestControllerTest { @RequestMapping(&quot;/getJsonObject&quot;) public JSONObject getJsonObject(){ JSONObject jsonObject = new JSONObject(); jsonObject.put(&quot;id&quot;,1); jsonObject.put(&quot;name&quot;,&quot;gekun&quot;); return jsonObject; } }]]></content>
      <categories>
        <category>springmvc</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Stream]]></title>
    <url>%2FBlog%2F2018%2F12%2F02%2Fstream%2F</url>
    <content type="text"><![CDATA[流常用用法List =&gt; Map&lt;Integer,Obj&gt;public static void listObjTomapIntergerObj(){ List&lt;User&gt; users = Arrays.asList(new User(1, &quot;Tomcat&quot;), new User(2, &quot;Apache&quot;), new User(3, &quot;Nginx&quot;)); //方法一 Map&lt;Integer, User&gt; map = users.stream().collect(Collectors.toMap(obj -&gt; obj.getId() , obj -&gt; obj)); //方法二maven-compiler-plugin //Map&lt;Integer, User&gt; map = users.stream().collect(Collectors.toMap(User::getId , obj -&gt; obj)); System.out.println(map); } List =&gt; Listpublic static void listMapTolistString(){ List&lt;Map&lt;String, String&gt;&gt; list = new ArrayList&lt;&gt;(); Map&lt;String, String&gt; map1 = new HashMap&lt;&gt;(); map1.put(&quot;id&quot;, &quot;101&quot;); map1.put(&quot;name&quot;, &quot;Tomcat&quot;); Map&lt;String, String&gt; map2 = new HashMap&lt;&gt;(); map2.put(&quot;id&quot;, &quot;102&quot;); map2.put(&quot;name&quot;, &quot;Apache&quot;); Map&lt;String, String&gt; map3 = new HashMap&lt;&gt;(); map3.put(&quot;id&quot;, &quot;103&quot;); map3.put(&quot;name&quot;, &quot;Nginx&quot;); list.add(map1); list.add(map2); list.add(map3); //方法一 List&lt;String&gt; ids = list.stream().map(entity -&gt; entity.get(&quot;id&quot;)).collect(Collectors.toList()); //方法二 //List&lt;Object&gt; ids = Arrays.asList(list.stream().map(entity -&gt; entity.get(&quot;id&quot;)).toArray()); System.out.println(ids); } String =&gt; Mappublic static void strTomap(){ String str = &quot;type=1&amp;from=APP&amp;source=homePage&quot;; Map&lt;String, String&gt; map = Stream.of(str.split(&quot;&amp;&quot;)).map(obj -&gt; obj.split(&quot;=&quot;)).collect(Collectors.toMap(entry -&gt; entry[0], entry -&gt; entry[1])); System.out.println(map); } List =&gt; Listpublic static void listStrTolistInteger(){ List&lt;String&gt; strs = Arrays.asList(&quot;1&quot;,&quot;2&quot;,&quot;3&quot;); List&lt;Integer&gt; ints = strs.stream().map(obj -&gt; Integer.valueOf(obj)).collect(Collectors.toList()); }]]></content>
      <categories>
        <category>java se</category>
      </categories>
      <tags>
        <tag>class</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ThreadPool]]></title>
    <url>%2FBlog%2F2018%2F12%2F02%2F%E7%BA%BF%E7%A8%8B%E6%B1%A0%2F</url>
    <content type="text"><![CDATA[手动创建线程池引入guava包，方便创建线程工厂类&lt;dependency&gt; &lt;groupId&gt;com.google.guava&lt;/groupId&gt; &lt;artifactId&gt;guava&lt;/artifactId&gt; &lt;version&gt;27.0.1-jre&lt;/version&gt; &lt;/dependency&gt; 代码public class ThreadPoolByHand { /** * 手动创建线程 * 默认5条线程（即最小数量） * 最大20线程（指定了线程中的最大线程数量） * 空闲时间0秒 * 等待队列长度1024 * 线程名称，方便回溯 * 拒绝策略，当队列任务已满，抛出RejectedExecutionException异常 */ private static ThreadPoolExecutor threadPool = new ThreadPoolExecutor(5, 20, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;(1024),new ThreadFactoryBuilder().setNameFormat(&quot;ByHand-%d&quot;).build(), new ThreadPoolExecutor.AbortPolicy()); static class MyRunable implements Runnable{ String name; public MyRunable(String name) { this.name = name; } @Override public void run() { System.out.println(&quot;正在执行：Thread ID：&quot; + Thread.currentThread().getId() + &quot; Name=&quot; + name); try { Thread.sleep(100); } catch (InterruptedException e) { e.printStackTrace(); } } } public static void main(String[] arg) { for (int i = 0; i &lt; 500; i++) { MyRunable myRunable = new MyRunable(&quot;r&quot;+i); threadPool.execute(myRunable); } threadPool.shutdown(); } }]]></content>
      <categories>
        <category>concurrent</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[发送邮件]]></title>
    <url>%2FBlog%2F2018%2F11%2F30%2FSendEmail%2F</url>
    <content type="text"><![CDATA[引入pom依赖&lt;dependency&gt; &lt;groupId&gt;org.apache.commons&lt;/groupId&gt; &lt;artifactId&gt;commons-email&lt;/artifactId&gt; &lt;version&gt;${commons-email.version}&lt;/version&gt; &lt;/dependency&gt; 发送流程 构建一个继承自javax.mail.Authenticator的具体类，并重写里面的getPasswordAuthentication()方法。用作登录校验，以确保你对该邮箱有发送邮件的权利。 构建一个properties文件，该文件中存放SMTP服务器地址等参数。 通过构建的properties文件和javax.mail.Authenticator具体类来创建一个javax.mail.Session。Session的创建，相当于登录邮箱一样。 构建邮件内容，一般是javax.mail.internet.MimeMessage对象，并指定发送人，收信人，主题，内容等等。 使用javax.mail.Transport工具类发送邮件。 代码public class SendEmail { //发送邮箱的账号密码 private static String userName=&quot;xxxxxxx@qq.com&quot;;//账号 private static String password=&quot;xxxxxxxx&quot;;//16位STMP口令 private static String nickName=&quot;CESHI&quot;;//昵称,可自定义 private static String smtp=&quot;smtp.qq.com&quot;;//SMTP服务器地址 //收件人邮箱的账号昵称 private static String receiveUserName=&quot;xxx@xxxx&quot;;//账号 private static String receiveNickName=&quot;AAAAA&quot;;//昵称,可自定义 public static void main(String[] args) throws Exception { //1、构建一个继承自javax.mail.Authenticator的具体类 // 并重写里面的getPasswordAuthentication()方法 // 此类是用作登录校验的，以确保你对该邮箱有发送邮件的权利。 Authenticator auth = new Authenticator() { @Override protected PasswordAuthentication getPasswordAuthentication() { return new PasswordAuthentication(SendEmail.userName,SendEmail.password); } }; //2、构建一个properties文件，该文件中存放SMTP服务器地址等参数。 Properties properties = new Properties(); // 使用的协议（JavaMail规范要求） properties.setProperty(&quot;mail.transport.protocol&quot;, &quot;smtp&quot;); // 发件人的邮箱的 SMTP 服务器地址,不同的服务器地址不同 properties.setProperty(&quot;mail.smtp.host&quot;, SendEmail.smtp); // 需要请求认证 properties.setProperty(&quot;mail.smtp.auth&quot;, &quot;true&quot;); // QQ邮箱端口587 properties.setProperty(&quot;mail.smtp.port&quot;, &quot;587&quot;); //3、通过构建的properties文件和javax.mail.Authenticator具体类来创建一个javax.mail.Session // Session的创建，就相当于登录邮箱。 Session session = Session.getDefaultInstance(properties, auth); // 设置为debug模式, 可以查看详细的发送 log session.setDebug(true); //4、构建邮件内容，一般是javax.mail.internet.MimeMessage对象 // 并指定发送人，收信人，主题，内容等等。 MimeMessage mimeMessage = new MimeMessage(session); //发件人,昵称,编码 mimeMessage.setFrom(new InternetAddress(SendEmail.userName,SendEmail.nickName, &quot;UTF-8&quot;)); //收件人,昵称,编码 //MimeMessage.RecipientType为发送方式 mimeMessage.setRecipient(MimeMessage.RecipientType.TO, new InternetAddress(SendEmail.receiveUserName, SendEmail.receiveNickName, &quot;UTF-8&quot;)); mimeMessage.setSubject(&quot;测试主题&quot;); mimeMessage.setText(&quot;测试内容&quot;); //5、使用javax.mail.Transport工具类发送邮件。 Transport transport = session.getTransport(); transport.connect(SendEmail.userName,SendEmail.password); transport.sendMessage(mimeMessage,mimeMessage.getAllRecipients()); } }]]></content>
      <categories>
        <category>java ee</category>
      </categories>
      <tags>
        <tag>email</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[lombok]]></title>
    <url>%2FBlog%2F2018%2F11%2F30%2Flombok%2F</url>
    <content type="text"><![CDATA[Lombok介绍 是一款Java开发插件 通过其定义的一些注解来消除业务工程中冗长和繁琐的代码，尤其对于简单的Java模型对象（POJO） 在代码编译的时候自动生成这些方法，并非在运行时生成。 使用 Intellij中安装lombok插件 在项目中加入lombok依赖 使用规则@Getter and @Setter 注释在类或字段上，自动生成get和set方法@ToString 生成toString()方法，默认情况下，它会按顺序（以逗号分隔）打印你的类名称以及每个字段。可以这样设置不包含哪些字段@ToString(exclude = “id”) @NoArgsConstructor @NoArgsConstructor生成一个无参构造器 可用@NoArgsConstructor(force = true)，然后就会为没有初始化的final字段设置默认值 0 / false / null。@AllArgsConstructor 生成一个全参数的构造方法@Data @Data 包含了 @ToString、@EqualsAndHashCode、@Getter / @Setter和@RequiredArgsConstructor的功能]]></content>
      <categories>
        <category>idea</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[try-with-resources]]></title>
    <url>%2FBlog%2F2018%2F11%2F30%2Ftry-with-resources%2F</url>
    <content type="text"><![CDATA[自动关闭资源 Java 7增强了try语句的功能 允许在try关键字后跟一对圆括号，圆括号可以声明，初始化一个或多个资源，此处的资源指得是那些必须在程序结束时必须关闭的资源（比如数据库连接，网络连接等） try语句在该语句结束时自动关闭这些资源 这些资源实现类必须实现Closeable或AutoCloseable接口，实现这些类就必须实现close方法。 代码public class TryWithResource { public static void main(String[] args) throws IOException { try ( // 声明、初始化两个可关闭的资源 // try语句会自动关闭这两个资源。 BufferedReader br = new BufferedReader(new FileReader(&quot;TryWithResource.java&quot;)); PrintStream ps = new PrintStream(new FileOutputStream(&quot;a.txt&quot;))) { // 使用两个资源 System.out.println(br.readLine()); ps.println(&quot;输出资源&quot;); } } }]]></content>
      <categories>
        <category>java se</category>
      </categories>
      <tags>
        <tag>class</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常用软件]]></title>
    <url>%2FBlog%2F2018%2F11%2F30%2F%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7%2F</url>
    <content type="text"><![CDATA[系统工具 名称 描述 MyBase 个人文档管理 BaiduNetdisk 云 Rolan2 快速启动软件 CCleaner 快速垃圾清理 cports 电脑端口查看 Ditto 复制记录 everything 全文件系统搜索 FastStone 截图录屏 Snipaste 截图可固定 Huorong 系统杀毒检测 leanote 个人文档管理 sunny-ngrok 内外网穿透 PowerCHM 文件转换为chm Registry Workshop 注册表管理 ShadowsocksR 翻墙 totalcommander 快速文件操作 Xmanager X窗口系统 putty x窗口系统 SumatraPDF 轻量级PDF工具 iSlide ppt插件 GreenChrome chrome增强软件 jsrun js在线编辑，可代码存储分享 WinSCP window下与远程计算机(linux)连接，文件传输 onTop 窗口置顶 winTop 窗口置顶 Mydm 多线程下载 jekyll+github 搭建个人博客 dropit 文件管理工具 mactype window字体优化 rainmeter 电脑界面主题修改 fiddler http协议调试工具 sourcetree git可视化工具 foldersizes 磁盘管理工具 Chrome插件 名称 描述 SwitchyOmega 代理管理 Clear Cache 清理缓存 LassPass 密码管理 Vysor 手机电脑同步 Adblock Plus 弹窗拦截 Infinity 标签页 Octotree GITHUB左侧树形展示 Video DownloadHelper 浏览器视频下载 ElasticSearch Head ElasticSearch Head扩展 超级二维码 生成二维码 开发工具箱 数据处理工具箱 yformater json格式化 idea插件 名称 描述 lombak 自动生成getset等代码 .ignore 创建ignore文件模板 p3c 阿里巴巴代码规范 GsonFormat json一键生成java类 FindBugs-IDEA 检查代码不规范 Maven Helper maven查看依赖 VisualVM Launcher 启动程序同时启动visualvm GenerateAllSetter 一键调用对象所有set方法 MyBatisCodeHelperPro 自动代码生成 Translation 翻译 Eclipse Code Formatter 使用 Eclipse 的代码格式化风格]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>software</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[slf4j注解简化日志代码]]></title>
    <url>%2FBlog%2F2018%2F11%2F29%2F%40Slf4j%2F</url>
    <content type="text"><![CDATA[pom中添加依赖&lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;/dependency&gt; 在类上添加@Slf4j注解@Slf4j public class Test { } 作用 类中不需要写private final Logger logger = LoggerFactory.getLogger(XXX.class); 直接在代码中使用loglog.debug(&quot;debug message&quot;); log.warn(&quot;warn message&quot;); log.info(&quot;info message&quot;); log.error(&quot;error message&quot;); log.trace(&quot;trace message&quot;); 如果注解@Slf4j注入后找不到变量log，需要安装lombok插件]]></content>
      <categories>
        <category>日志</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[数据摘要算法]]></title>
    <url>%2FBlog%2F2018%2F11%2F29%2F%E6%95%B0%E6%8D%AE%E6%91%98%E8%A6%81%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[数据摘要算法简介 数据摘要算法也被称为哈希（Hash）算法或散列算法。 把任意长度的输入，通过散列算法，变换成固定长度的输出，该输出就是散列值。 是一种压缩映射，即散列值的空间通常远小于输入的空间，不同的输入可能会散列成相同的输出，而不可能从散列值来唯一的确定输入值。 是一种将任意长度的消息压缩到某一固定长度的消息摘要的函数。 MD5 和 SHA1 可以说是目前应用最广泛的Hash算法，是以 MD4 为基础设计的。 CRC8,CRC16,CRC32 循环冗余校验 CRC32是通讯领域最多的算法 严格的来说，CRC更应该被称为数据校验算法，但其功能与数据摘要算法类似 在 WinRAR、WinZIP 等软件中，也是以 CRC32 作为文件校验算法的。 public static long crc32(String data) { java.util.zip.CRC32 crc = new java.util.zip.CRC32(); crc.update(data.getBytes()); return crc.getValue(); }]]></content>
      <categories>
        <category>加密</category>
      </categories>
      <tags>
        <tag>hash</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[拦截器]]></title>
    <url>%2FBlog%2F2018%2F11%2F29%2F%E6%8B%A6%E6%88%AA%E5%99%A8%2F</url>
    <content type="text"><![CDATA[新建类实现HandlerInterceptor或者继承HandlerInterceptorAdapterpublic class SessionInterceptor extends HandlerInterceptorAdapter { //spring-mvc配置文件中增加此类 @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception { System.out.println(&quot;preHandle&quot;); return super.preHandle(request, response, handler); } @Override public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception { System.out.println(&quot;postHandle&quot;); super.postHandle(request, response, handler, modelAndView); } @Override public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception { System.out.println(&quot;afterCompletion&quot;); super.afterCompletion(request, response, handler, ex); } } 在springmvc配置文件中增加此类&lt;mvc:interceptors&gt; &lt;mvc:interceptor&gt; &lt;mvc:mapping path=&quot;/**&quot;/&gt; &lt;mvc:exclude-mapping path=&quot;/login&quot;/&gt; &lt;bean class=&quot;joseph.study.springmvc.interceptors.SessionInterceptor&quot;/&gt; &lt;/mvc:interceptor&gt; &lt;/mvc:interceptors&gt;]]></content>
      <categories>
        <category>springmvc</category>
      </categories>
      <tags>
        <tag>Interceptor</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[logback]]></title>
    <url>%2FBlog%2F2018%2F11%2F27%2Flogback%2F</url>
    <content type="text"><![CDATA[概述 logback是由log4j创始人设计的又一个开源日志组件 logback当前分成三个模块：logback-core,logback-classic和logback-access logback-core是其它两个模块的基础模块 logback-classic是log4j的一个改良版本 logback-classic完整实现SLF4J API使你可以很方便地更换成其它日志系统如log4j或JDK14 Logging logback-access访问模块与Servlet容器集成提供通过Http来访问日志的功能(用的少) logback-classic和logback-access已经依赖logback-core,不需要单独引用 maven依赖 &lt;!--logback start--&gt; &lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt; &lt;version&gt;1.7.21&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt; &lt;artifactId&gt;logback-classic&lt;/artifactId&gt; &lt;version&gt;1.1.7&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt; &lt;artifactId&gt;logback-access&lt;/artifactId&gt; &lt;version&gt;1.1.7&lt;/version&gt; &lt;/dependency&gt; &lt;!--logback end --&gt; &lt;/dependencies&gt; 常用配置文件配置&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;configuration scan=&quot;true&quot; scanPeriod=&quot;60 seconds&quot; debug=&quot;true&quot;&gt; &lt;!-- 从高到地低 OFF 、 FATAL 、 ERROR 、 WARN 、 INFO 、 DEBUG 、 TRACE 、 ALL --&gt; &lt;!-- scan：性设置为true时，配置文件如果发生改变，将会被重新加载，默认值为true scanPeriod:设置监测配置文件是否有修改的时间间隔，如果没有给出时间单位，默认单位是毫秒。当scan为true时，此属性生效。默认的时间间隔为1分钟 debug:当此属性设置为true时，将打印出logback内部日志信息，实时查看logback运行状态。默认值为false --&gt; &lt;!--设置日志上下文名称，后面输出格式中可以通过定义 %contextName 来打印日志上下文名称--&gt; &lt;contextName&gt;logback&lt;/contextName&gt; &lt;!-- 定义日志文件 输入位置 --&gt; &lt;property name=&quot;log_dir&quot; value=&quot;E:/studylogs&quot; /&gt; &lt;!-- 日志最大的历史 30天 --&gt; &lt;property name=&quot;maxHistory&quot; value=&quot;30&quot; /&gt; &lt;!-- ConsoleAppender 控制台输出日志 --&gt; &lt;appender name=&quot;stdout&quot; class=&quot;ch.qos.logback.core.ConsoleAppender&quot;&gt; &lt;!--过滤掉所有低于info级别的日志。 --&gt; &lt;filter class=&quot;ch.qos.logback.classic.filter.ThresholdFilter&quot;&gt; &lt;level&gt;info&lt;/level&gt; &lt;/filter&gt; &lt;!-- 对日志进行格式化 --&gt; &lt;encoder&gt; &lt;pattern&gt;%d{yyyy-MM-dd HH:mm:ss} [%thread] %-5level %logger -%msg%n &lt;/pattern&gt; &lt;charset&gt;UTF-8&lt;/charset&gt; &lt;!-- 此处设置字符集 --&gt; &lt;/encoder&gt; &lt;/appender&gt; &lt;!-- DEBUG级别日志 appender --&gt; &lt;appender name=&quot;debug&quot; class=&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;&gt; &lt;!-- 过滤器，只记录info级别的日志 --&gt; &lt;filter class=&quot;ch.qos.logback.classic.filter.LevelFilter&quot;&gt; &lt;level&gt;info&lt;/level&gt; &lt;onMatch&gt;ACCEPT&lt;/onMatch&gt; &lt;onMismatch&gt;DENY&lt;/onMismatch&gt; &lt;/filter&gt; &lt;rollingPolicy class=&quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&quot;&gt; &lt;!-- 按天回滚 daily --&gt; &lt;fileNamePattern&gt;${log_dir}/%d{yyyy-MM-dd}/debug-log.log &lt;/fileNamePattern&gt; &lt;!-- 日志最大的历史 60天 --&gt; &lt;maxHistory&gt;${maxHistory}&lt;/maxHistory&gt; &lt;/rollingPolicy&gt; &lt;encoder&gt; &lt;pattern&gt;%d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level %logger - %msg%n&lt;/pattern&gt; &lt;charset&gt;UTF-8&lt;/charset&gt; &lt;!-- 此处设置字符集 --&gt; &lt;/encoder&gt; &lt;/appender&gt; &lt;!-- ERROR级别日志 --&gt; &lt;!-- 滚动记录文件，先将日志记录到指定文件，当符合某个条件时，将日志记录到其他文件 RollingFileAppender --&gt; &lt;appender name=&quot;ERROR&quot; class=&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;&gt; &lt;!-- 过滤器，只记录WARN级别的日志 --&gt; &lt;filter class=&quot;ch.qos.logback.classic.filter.LevelFilter&quot;&gt; &lt;level&gt;ERROR&lt;/level&gt; &lt;onMatch&gt;ACCEPT&lt;/onMatch&gt; &lt;onMismatch&gt;DENY&lt;/onMismatch&gt; &lt;/filter&gt; &lt;!-- 最常用的滚动策略，它根据时间来制定滚动策略.既负责滚动也负责出发滚动 --&gt; &lt;rollingPolicy class=&quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&quot;&gt; &lt;!--日志输出位置 可相对、和绝对路径 --&gt; &lt;fileNamePattern&gt;${log_dir}/%d{yyyy-MM-dd}/error-log.log &lt;/fileNamePattern&gt; &lt;!-- 可选节点，控制保留的归档文件的最大数量，超出数量就删除旧文件假设设置每个月滚动，且&lt;maxHistory&gt;是6， 则只保存最近6个月的文件，删除之前的旧文件。注意，删除旧文件是，那些为了归档而创建的目录也会被删除 --&gt; &lt;maxHistory&gt;${maxHistory}&lt;/maxHistory&gt; &lt;/rollingPolicy&gt; &lt;encoder&gt; &lt;pattern&gt;%d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level %logger - %msg%n&lt;/pattern&gt; &lt;charset&gt;UTF-8&lt;/charset&gt; &lt;!-- 此处设置字符集 --&gt; &lt;/encoder&gt; &lt;/appender&gt; &lt;!-- root级别 DEBUG --&gt; &lt;root level=&quot;debug&quot;&gt; &lt;!--定义了两个appender，日志会通过往这两个appender里面写--&gt; &lt;appender-ref ref=&quot;stdout&quot;/&gt; &lt;appender-ref ref=&quot;debug&quot;/&gt; &lt;/root&gt; &lt;!--这个logger没有指定appender，它会继承root节点中定义的那些appender--&gt; &lt;logger name=&quot;joseph.study.Logback&quot; level=&quot;info&quot;/&gt; &lt;!--通过 LoggerFactory.getLogger(&quot;mytest&quot;) 可以获取到这个logger--&gt; &lt;!--由于这个logger自动继承了root的appender，root中已经有stdout的appender了，自己这边又引入了stdout的appender--&gt; &lt;!--如果没有设置 additivity=&quot;false&quot; ,就会导致一条日志在控制台输出两次的情况--&gt; &lt;!--additivity表示要不要使用rootLogger配置的appender进行输出--&gt; &lt;logger name=&quot;mytest&quot; level=&quot;DEBUG&quot; additivity=&quot;false&quot;&gt; &lt;appender-ref ref=&quot;stdout&quot;/&gt; &lt;/logger&gt; &lt;/configuration&gt;]]></content>
      <categories>
        <category>日志</category>
      </categories>
      <tags>
        <tag>logback</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[StringTokenizer]]></title>
    <url>%2FBlog%2F2018%2F11%2F27%2FStringTokenizer%2F</url>
    <content type="text"><![CDATA[不指定分隔符使用默认的，即“ \t\n\r\f”:空格字符、制表符、换行字符、回车字符和表单输入字符 StringTokenizer token = new StringTokenizer(&quot;Hello world!This is Java code,stringTokenizer Demo.&quot;); while (token.hasMoreElements()) { System.out.println(token.nextToken()); } //输出 Hello world!This is Java code,stringTokenizer Demo. 指定分隔符，将按照指定的分隔符分隔，忽略默认分隔符，并且不返回分隔符令牌StringTokenizer token = new StringTokenizer(&quot;Hello world!This is Java code,stringTokenizer Demo.&quot;,&quot;s!,.&quot;); while (token.hasMoreElements()) { System.out.println(token.nextToken()); } //输出 Hello world Thi i Java code tringTokenizer Demo 指定分隔符，并指定返回令牌为true，将按照指定的分隔符分隔，忽略默认分隔符，并且返回分隔符令牌StringTokenizer token = new StringTokenizer(&quot;Hello world!This is Java code,stringTokenizer Demo.&quot;,&quot;s!,.&quot;,true); while (token.hasMoreElements()) { System.out.println(token.nextToken()); } //输出 Hello world ! Thi s i s Java code , s tringTokenizer Demo .]]></content>
      <categories>
        <category>java se</category>
      </categories>
      <tags>
        <tag>class</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[sql执行顺序]]></title>
    <url>%2FBlog%2F2018%2F11%2F26%2Fsql%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[SQL逻辑查询语句执行顺序(7) SELECT (8) DISTINCT &lt;select_list&gt; (1) FROM &lt;left_table&gt; (3) &lt;join_type&gt; JOIN &lt;right_table&gt; (2) ON &lt;join_condition&gt; (4) WHERE &lt;where_condition&gt; (5) GROUP BY &lt;group_by_list&gt; (6) HAVING &lt;having_condition&gt; (9) ORDER BY &lt;order_by_condition&gt; (10) LIMIT &lt;limit_number&gt;]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>sql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常用sql]]></title>
    <url>%2FBlog%2F2018%2F11%2F26%2F%E5%B8%B8%E7%94%A8sql%2F</url>
    <content type="text"><![CDATA[常用sql查询数据库中表的统计信息SELECT col.TABLE_SCHEMA 数据库, col.TABLE_NAME 表名称, tal.TABLE_ROWS 数据规模, tal.table_comment 表描述, col.COLUMN_NAME 字段名称, col.COLUMN_COMMENT 字段描述, IFNULL( pri.shiz, 0 ) 是否主键, IFNULL( ind.shis, 0 ) 是否索引, col.IS_NULLABLE 是否可空, col.CHARACTER_MAXIMUM_LENGTH 字段长度, col.DATA_TYPE 字段类型 FROM `information_schema`.`columns` col LEFT JOIN information_schema.`TABLES` tal ON col.TABLE_NAME = tal.TABLE_NAME LEFT JOIN ( SELECT t.TABLE_NAME, c.COLUMN_NAME, &apos;1&apos; AS shiz FROM INFORMATION_SCHEMA.TABLE_CONSTRAINTS AS t, INFORMATION_SCHEMA.KEY_COLUMN_USAGE AS c WHERE t.TABLE_NAME = c.TABLE_NAME AND t.TABLE_SCHEMA = &apos;lmpdb&apos; AND t.CONSTRAINT_TYPE = &apos;PRIMARY KEY&apos; ) pri ON pri.TABLE_NAME = col.TABLE_NAME AND pri.COLUMN_NAME = col.COLUMN_NAME LEFT JOIN ( SELECT table_name, COLUMN_NAME, &apos;1&apos; AS shis FROM INFORMATION_SCHEMA.STATISTICS WHERE TABLE_SCHEMA = &apos;lmpdb&apos; ) ind ON ind.table_name = col.TABLE_NAME AND ind.COLUMN_NAME = col.COLUMN_NAME WHERE col.TABLE_SCHEMA = &apos;lmpdb&apos; ORDER BY col.TABLE_NAME 按时间统计信息 SELECT t.days, count( * ) count FROM ( SELECT DATE_FORMAT( l.cdate, &apos;%Y%m%d&apos; ) days FROM login_log l ) t GROUP BY t.days 使用in查询后按in数据排序SELECT * FROM user_info WHERE user_info.user_code IN ( 01463843, 01416140, 01475304, 01466211) ORDER BY field( user_code, 01463843, 01416140, 01475304, 01466211) 三种成绩排序查询&lt;select id=&quot;getRankFirst&quot; resultMap=&quot;aiExamCandidateMap&quot;&gt; SELECT user_code, user_name, exam_id, gross_score, exam_score, @rownum := @rownum + 1 as ranking FROM ai_exam_candidate t join (select @rownum :=0) r WHERE exam_id = #{model.examId} and exam_score is not null ORDER BY exam_score desc &lt;/select&gt; &lt;select id=&quot;getRankSecond&quot; resultMap=&quot;aiExamCandidateMap&quot;&gt; SELECT user_code, user_name, exam_id, gross_score, exam_score, CASE WHEN @rowtotal = exam_score THEN @rownum WHEN @rowtotal := exam_score THEN @rownum := @rownum + 1 WHEN @rowtotal := 0 THEN @rownum := @rownum +1 WHEN exam_score is null then @rownum+1 END AS ranking FROM ai_exam_candidate t join (select @rownum :=0,@rowtotal := 0) r WHERE exam_id = #{model.examId} and exam_score is not null ORDER BY exam_score desc &lt;/select&gt; &lt;select id=&quot;getRankThird&quot; resultMap=&quot;aiExamCandidateMap&quot;&gt; SELECT user_code, user_name, exam_id, gross_score, exam_score, @rownum := @rownum + 1 AS num_tmp, @incrnum := CASE WHEN @rowtotal = exam_score THEN @incrnum WHEN @rowtotal := exam_score THEN @rownum WHEN exam_score is null THEN @rownum END ranking FROM ai_exam_candidate t join (select @rownum :=0,@rowtotal := 0,@incrnum := 0) r WHERE exam_id = #{model.examId} and exam_score is not null ORDER BY exam_score desc &lt;/select&gt;]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>sql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[idea常用快捷键]]></title>
    <url>%2FBlog%2F2018%2F11%2F26%2Fidea%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE%2F</url>
    <content type="text"><![CDATA[CTRL+ALT+T 把选中的代码放在 TRY{} IF{} ELSE{} 里Ctrl + I 实现方法Ctrl + O 重写方法Ctr+shift+U 大小写转化Ctrl+Shift+J 整合两行为一行CTRL+ALT+L 格式化代码CTRL+P 方法参数提示CTRL+Q 可以看到当前方法的声明Shift+F6 重构-重命名 (包、类、方法、变量、甚至注释等)Ctrl＋Shift＋Backspace可以跳转到上次编辑的地CTRL+ALT+ left/right 前后导航编辑过的地方Alt+ left/right 切换代码视图ALT+ ↑/↓ 在方法间快速移动定位ALT+F7 找到你的函数或者变量或者类的所有引用到的地方Ctrl+N 查找类Ctrl+Shift+N 查找文件CTRL+E 最近打开的文件F2 警告快速定位CTRL+ALT+B 找所有的子类Ctrl+H 显示类结构图Ctrl+Q 显示注释文档CTRL+Z 倒退(撤销)CTRL+SHIFT+Z 向前(取消撤销)Shift+F6 重命名(包括文件名，变量名批量修改)]]></content>
      <categories>
        <category>idea</category>
      </categories>
      <tags>
        <tag>idea</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ie发送请求时中文乱码，无法访问]]></title>
    <url>%2FBlog%2F2018%2F11%2F26%2Fie%E5%8F%91%E9%80%81%E8%AF%B7%E6%B1%82%E6%97%B6%E4%B8%AD%E6%96%87%E4%B9%B1%E7%A0%81%EF%BC%8C%E6%97%A0%E6%B3%95%E8%AE%BF%E9%97%AE%2F</url>
    <content type="text"><![CDATA[在封装ajax时，使用encodeURI（）方法对url进行编码$.ajax({ type:&quot;post&quot;, url:encodeURI(&quot;http://localhost:8080/test/test?name=测试&quot;), success:function(){ } })]]></content>
      <categories>
        <category>前端</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[select2与bootstrap模态框显示冲突]]></title>
    <url>%2FBlog%2F2018%2F11%2F26%2Fselect2%E4%B8%8Ebootstrap%E6%A8%A1%E6%80%81%E6%A1%86%E6%98%BE%E7%A4%BA%E5%86%B2%E7%AA%81%2F</url>
    <content type="text"><![CDATA[select2 加入 dropdownParent 属性，设置父元素modal$(&quot;.select2-demo&quot;).select2({ dropdownParent:$(&quot;#Modal-demo&quot;) }); css设置，让select2的选择弹出层位于最上层，否则将被modal遮挡住.select2-drop { z-index: 10050 !important; } .select2-search-choice-close { margin-top: 0 !important; right: 2px !important; min-height: 10px; } .select2-search-choice-close:before { color: black !important; } /*防止select2不会自动失去焦点*/ .select2-container { z-index: 16000 !important; } .select2-drop-mask { z-index: 15990 !important; } .select2-drop-active { z-index: 15995 !important; }]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>select2冲突</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[idea中设置toString为json格式]]></title>
    <url>%2FBlog%2F2018%2F11%2F26%2Fidea%E4%B8%AD%E8%AE%BE%E7%BD%AE%E7%94%9F%E6%88%90toString%E4%B8%BAjson%2F</url>
    <content type="text"><![CDATA[shift+g 调出生成对话框，点击toString()，弹出Generate toString()对话框 点击setting按钮，打开对话框后选择Templates选项新建一个模板，可以模仿StringBuffer模板 public java.lang.String toString() { final java.lang.StringBuilder sb = new java.lang.StringBuilder(&quot;{&quot;); #set ($i = 0) #foreach ($member in $members)#if ($i == 0) sb.append(&quot;##### #else sb.append(&quot;,#### #end#if ($member.string || $member.date) \&quot;$member.name\&quot;:\&quot;&quot;) #else \&quot;$member.name\&quot;:&quot;) #end#if ($member.primitiveArray || $member.objectArray) .append(java.util.Arrays.toString($member.name)); #elseif ($member.string || $member.date) .append($member.accessor).append(&apos;\&quot;&apos;); #else .append($member.accessor); #end#set ($i = $i + 1) #end sb.append(&apos;}&apos;); return sb.toString(); } 重写toString()时可以使用此模板生成]]></content>
      <categories>
        <category>idea</category>
      </categories>
      <tags>
        <tag>idea</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[页面刷新一次]]></title>
    <url>%2FBlog%2F2018%2F11%2F26%2F%E5%89%8D%E7%AB%AF%E9%A1%B5%E9%9D%A2%E5%88%B7%E6%96%B0%E4%B8%80%E6%AC%A1%2F</url>
    <content type="text"><![CDATA[页面刷新一次 window.onload = function(){ var url=document.location.href; //获取浏览器访问栏里的地址 if( url.indexOf(&quot;rflag=&quot;)==-1 ){ //判断地址后面是否多了某些值，没有就进方法里进行刷新 var t = new Date(); window.location.href = url+&quot;?rflag=&quot;+t.getTime(); } }]]></content>
      <categories>
        <category>前端</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[页面刷新一次]]></title>
    <url>%2FBlog%2F2018%2F11%2F26%2F%E9%A1%B5%E9%9D%A2%E5%85%BC%E5%AE%B9%E6%80%A7%2F</url>
    <content type="text"><![CDATA[IE页面样式错乱12//在head中增加以下&lt;meta http-equiv="x-ua-compatible" content="IE=9;IE=8;IE=7;IE=EDGE"&gt; IE中textarea变成一条线 原因是由于ie在将&lt;textarea&gt;&lt;/textarea&gt;这种标签变成&lt;textarea/&gt;,没有内容的textarea会有问题 12//使用如下方式曲线救国&lt;textarea onFocus="if(value==defaultValue)&#123;value=''&#125;" onBlur="if(!value)&#123;value=defaultValue;&#125;"&gt;请填写&lt;/textarea&gt;]]></content>
      <categories>
        <category>前端</category>
      </categories>
  </entry>
</search>
