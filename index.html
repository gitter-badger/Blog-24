<!DOCTYPE HTML>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  
  <title>你的ENTER键价值千亿</title>
  <meta name="author" content="JosephGK">
  
  <meta name="description" content="gekun,葛坤">
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  
  <meta property="og:site_name" content="你的ENTER键价值千亿">

  
    <meta property="og:image" content="">
  

  <link href="/Blog/favicon.png" rel="icon">
  <link rel="alternate" href="/Blog/atom.xml" title="你的ENTER键价值千亿" type="application/atom+xml">
  <link rel="stylesheet" href="/Blog/css/style.css" media="screen" type="text/css">
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
  

</head>
</html>

<body>
  <header id="header" class="inner"><div class="alignleft">
  <h1><a href="/Blog/">你的ENTER键价值千亿</a></h1>
  <h2><a href="/Blog/"></a></h2>
</div>
<nav id="main-nav" class="alignright">
  <ul>
    
      <li><a href="/Blog/">主页</a></li>
    
      <li><a href="/Blog/archives">文档</a></li>
    
  </ul>
  <div class="clearfix"></div>
</nav>
<div class="clearfix"></div>
</header>
  <div id="content" class="inner">
    <div id="main-col" class="alignleft"><div id="wrapper">
  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2018-12-01T16:00:00.000Z"><a href="/Blog/2018/12/02/线程池/">2018-12-02</a></time>
      
      
  
    <h1 class="title"><a href="/Blog/2018/12/02/线程池/">ThreadPool</a></h1>
  

    </header>
    <div class="entry">
      
        <h2 id="手动创建线程池"><a href="#手动创建线程池" class="headerlink" title="手动创建线程池"></a>手动创建线程池</h2><h3 id="引入guava包，方便创建线程工厂类"><a href="#引入guava包，方便创建线程工厂类" class="headerlink" title="引入guava包，方便创建线程工厂类"></a>引入guava包，方便创建线程工厂类</h3><pre><code>&lt;dependency&gt;
    &lt;groupId&gt;com.google.guava&lt;/groupId&gt;
    &lt;artifactId&gt;guava&lt;/artifactId&gt;
    &lt;version&gt;27.0.1-jre&lt;/version&gt;
&lt;/dependency&gt;
</code></pre><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><pre><code>public class ThreadPoolByHand {

    /**
     * 手动创建线程
     * 默认5条线程（即最小数量）
     * 最大20线程（指定了线程中的最大线程数量）
     * 空闲时间0秒
     * 等待队列长度1024
     * 线程名称，方便回溯
     * 拒绝策略，当队列任务已满，抛出RejectedExecutionException异常
     */
    private static ThreadPoolExecutor threadPool = new ThreadPoolExecutor(5, 20, 0L, TimeUnit.MILLISECONDS,
            new LinkedBlockingQueue&lt;Runnable&gt;(1024),new ThreadFactoryBuilder().setNameFormat(&quot;ByHand-%d&quot;).build(), new ThreadPoolExecutor.AbortPolicy());

    static class MyRunable implements Runnable{
        String name;

        public MyRunable(String name) {
            this.name = name;
        }
        @Override public void run() {
            System.out.println(&quot;正在执行：Thread ID：&quot; + Thread.currentThread().getId() + &quot;   Name=&quot; + name);
            try {
                Thread.sleep(100);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }
    public static void main(String[] arg) {
        for (int i = 0; i &lt; 500; i++) {
            MyRunable myRunable = new MyRunable(&quot;r&quot;+i);
            threadPool.execute(myRunable);
        }
        threadPool.shutdown();
    }
}
</code></pre>
      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2018-12-01T16:00:00.000Z"><a href="/Blog/2018/12/02/stream/">2018-12-02</a></time>
      
      
  
    <h1 class="title"><a href="/Blog/2018/12/02/stream/">Stream</a></h1>
  

    </header>
    <div class="entry">
      
        <h2 id="流常用用法"><a href="#流常用用法" class="headerlink" title="流常用用法"></a>流常用用法</h2><h3 id="List-gt-Map-lt-Integer-Obj-gt"><a href="#List-gt-Map-lt-Integer-Obj-gt" class="headerlink" title="List =&gt; Map&lt;Integer,Obj&gt;"></a>List<obj> =&gt; Map&lt;Integer,Obj&gt;</obj></h3><pre><code>public static void listObjTomapIntergerObj(){
        List&lt;User&gt; users = Arrays.asList(new User(1, &quot;Tomcat&quot;), new User(2, &quot;Apache&quot;), new User(3, &quot;Nginx&quot;));
        //方法一
        Map&lt;Integer, User&gt; map = users.stream().collect(Collectors.toMap(obj -&gt; obj.getId() , obj -&gt; obj));
        //方法二maven-compiler-plugin
        //Map&lt;Integer, User&gt; map = users.stream().collect(Collectors.toMap(User::getId , obj -&gt; obj));
        System.out.println(map);
    }
</code></pre><h3 id="List-gt-List"><a href="#List-gt-List" class="headerlink" title="List  =&gt;  List"></a>List<map>  =&gt;  List<string></string></map></h3><pre><code>public static void listMapTolistString(){
    List&lt;Map&lt;String, String&gt;&gt; list = new ArrayList&lt;&gt;();
    Map&lt;String, String&gt; map1 = new HashMap&lt;&gt;();
    map1.put(&quot;id&quot;, &quot;101&quot;);
    map1.put(&quot;name&quot;, &quot;Tomcat&quot;);
    Map&lt;String, String&gt; map2 = new HashMap&lt;&gt;();
    map2.put(&quot;id&quot;, &quot;102&quot;);
    map2.put(&quot;name&quot;, &quot;Apache&quot;);
    Map&lt;String, String&gt; map3 = new HashMap&lt;&gt;();
    map3.put(&quot;id&quot;, &quot;103&quot;);
    map3.put(&quot;name&quot;, &quot;Nginx&quot;);
    list.add(map1);
    list.add(map2);
    list.add(map3);
    //方法一
    List&lt;String&gt; ids = list.stream().map(entity -&gt; entity.get(&quot;id&quot;)).collect(Collectors.toList());
    //方法二
    //List&lt;Object&gt; ids = Arrays.asList(list.stream().map(entity -&gt; entity.get(&quot;id&quot;)).toArray());
    System.out.println(ids);
}
</code></pre><h3 id="String-gt-Map"><a href="#String-gt-Map" class="headerlink" title="String  =&gt;  Map"></a>String  =&gt;  Map</h3><pre><code>public static void strTomap(){
    String str = &quot;type=1&amp;from=APP&amp;source=homePage&quot;;
    Map&lt;String, String&gt; map = Stream.of(str.split(&quot;&amp;&quot;)).map(obj -&gt; obj.split(&quot;=&quot;)).collect(Collectors.toMap(entry -&gt; entry[0], entry -&gt; entry[1]));
    System.out.println(map);
}
</code></pre><h3 id="List-gt-List-1"><a href="#List-gt-List-1" class="headerlink" title="List  =&gt;  List"></a>List<string>  =&gt;  List<integer></integer></string></h3><pre><code>public static void listStrTolistInteger(){
    List&lt;String&gt; strs = Arrays.asList(&quot;1&quot;,&quot;2&quot;,&quot;3&quot;);
    List&lt;Integer&gt; ints = strs.stream().map(obj -&gt; Integer.valueOf(obj)).collect(Collectors.toList());
}
</code></pre>
      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2018-11-29T16:00:00.000Z"><a href="/Blog/2018/11/30/SendEmail/">2018-11-30</a></time>
      
      
  
    <h1 class="title"><a href="/Blog/2018/11/30/SendEmail/">发送邮件</a></h1>
  

    </header>
    <div class="entry">
      
        <h2 id="引入pom依赖"><a href="#引入pom依赖" class="headerlink" title="引入pom依赖"></a>引入pom依赖</h2><pre><code>&lt;dependency&gt;
    &lt;groupId&gt;org.apache.commons&lt;/groupId&gt;
    &lt;artifactId&gt;commons-email&lt;/artifactId&gt;
    &lt;version&gt;${commons-email.version}&lt;/version&gt;
&lt;/dependency&gt;
</code></pre><h2 id="发送流程"><a href="#发送流程" class="headerlink" title="发送流程"></a>发送流程</h2><ul>
<li>构建一个继承自javax.mail.Authenticator的具体类，并重写里面的getPasswordAuthentication()方法。用作登录校验，以确保你对该邮箱有发送邮件的权利。</li>
<li>构建一个properties文件，该文件中存放SMTP服务器地址等参数。</li>
<li>通过构建的properties文件和javax.mail.Authenticator具体类来创建一个javax.mail.Session。Session的创建，相当于登录邮箱一样。</li>
<li>构建邮件内容，一般是javax.mail.internet.MimeMessage对象，并指定发送人，收信人，主题，内容等等。</li>
<li>使用javax.mail.Transport工具类发送邮件。</li>
</ul>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code>public class SendEmail {
    //发送邮箱的账号密码
    private static String userName=&quot;xxxxxxx@qq.com&quot;;//账号
    private static String password=&quot;xxxxxxxx&quot;;//16位STMP口令
    private static String nickName=&quot;CESHI&quot;;//昵称,可自定义
    private static String smtp=&quot;smtp.qq.com&quot;;//SMTP服务器地址
    //收件人邮箱的账号昵称
    private static String receiveUserName=&quot;xxx@xxxx&quot;;//账号
    private static String receiveNickName=&quot;AAAAA&quot;;//昵称,可自定义

    public static void main(String[] args) throws Exception {
        //1、构建一个继承自javax.mail.Authenticator的具体类
        //   并重写里面的getPasswordAuthentication()方法
        //   此类是用作登录校验的，以确保你对该邮箱有发送邮件的权利。
        Authenticator auth = new Authenticator() {
            @Override protected PasswordAuthentication getPasswordAuthentication() {
                return new PasswordAuthentication(SendEmail.userName,SendEmail.password);
            }
        };
        //2、构建一个properties文件，该文件中存放SMTP服务器地址等参数。
        Properties properties = new Properties();
        // 使用的协议（JavaMail规范要求）
        properties.setProperty(&quot;mail.transport.protocol&quot;, &quot;smtp&quot;);
        // 发件人的邮箱的 SMTP 服务器地址,不同的服务器地址不同
        properties.setProperty(&quot;mail.smtp.host&quot;, SendEmail.smtp);
        // 需要请求认证
        properties.setProperty(&quot;mail.smtp.auth&quot;, &quot;true&quot;);
        // QQ邮箱端口587
        properties.setProperty(&quot;mail.smtp.port&quot;, &quot;587&quot;);
        //3、通过构建的properties文件和javax.mail.Authenticator具体类来创建一个javax.mail.Session
        //   Session的创建，就相当于登录邮箱。
        Session session = Session.getDefaultInstance(properties, auth);
        // 设置为debug模式, 可以查看详细的发送 log
        session.setDebug(true);
        //4、构建邮件内容，一般是javax.mail.internet.MimeMessage对象
        //   并指定发送人，收信人，主题，内容等等。
        MimeMessage mimeMessage = new MimeMessage(session);
        //发件人,昵称,编码
        mimeMessage.setFrom(new InternetAddress(SendEmail.userName,SendEmail.nickName, &quot;UTF-8&quot;));
        //收件人,昵称,编码
        //MimeMessage.RecipientType为发送方式
        mimeMessage.setRecipient(MimeMessage.RecipientType.TO, new InternetAddress(SendEmail.receiveUserName, SendEmail.receiveNickName, &quot;UTF-8&quot;));
        mimeMessage.setSubject(&quot;测试主题&quot;);
        mimeMessage.setText(&quot;测试内容&quot;);
        //5、使用javax.mail.Transport工具类发送邮件。
        Transport transport = session.getTransport();
        transport.connect(SendEmail.userName,SendEmail.password);
        transport.sendMessage(mimeMessage,mimeMessage.getAllRecipients());
    }
}
</code></pre>
      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2018-11-29T16:00:00.000Z"><a href="/Blog/2018/11/30/常用工具/">2018-11-30</a></time>
      
      
  
    <h1 class="title"><a href="/Blog/2018/11/30/常用工具/">常用软件</a></h1>
  

    </header>
    <div class="entry">
      
        <h1 id="常用工具说明"><a href="#常用工具说明" class="headerlink" title="常用工具说明"></a>常用工具说明</h1><h2 id="系统工具"><a href="#系统工具" class="headerlink" title="系统工具"></a>系统工具</h2><p>Name|recommend<br>|:-:| :-: |<br>MyBase|个人文档管理<br>BaiduNetdisk|云<br>Rolan2|快速启动软件<br>CCleaner|快速垃圾清理<br>cports|电脑端口查看<br>Ditto|复制记录<br>everything|全文件系统搜索<br>FastStone|截图录屏<br>Snipaste|截图可固定<br>Huorong|系统杀毒检测<br>leanote|个人文档管理<br>sunny-ngrok|内外网穿透<br>PowerCHM|文件转换为chm<br>Registry Workshop|注册表管理<br>ShadowsocksR|翻墙<br>totalcommander|快速文件操作<br>Xmanager|X窗口系统<br>putty|x窗口系统<br>SumatraPDF|轻量级PDF工具<br>iSlide|ppt插件<br>GreenChrome|chrome增强软件<br>jsrun|js在线编辑，可代码存储分享<br>WinSCP|window下与远程计算机(linux)连接，文件传输<br>onTop|窗口置顶<br>winTop|窗口置顶<br>Mydm|多线程下载<br>jekyll+github|搭建个人博客<br>dropit|文件管理工具<br>mactype|window字体优化<br>rainmeter|电脑界面主题修改<br>fiddler|http协议调试工具</p>
<h2 id="Chrome插件"><a href="#Chrome插件" class="headerlink" title="Chrome插件"></a>Chrome插件</h2><p>Name|recommend<br>|:-:| :-: |<br>SwitchyOmega|代理管理<br>Clear Cache|清理缓存<br>LassPass|密码管理<br>Vysor|手机电脑同步<br>Adblock Plus|弹窗拦截<br>Infinity|标签页<br>Octotree|GITHUB左侧树形展示<br>Video DownloadHelper|浏览器视频下载</p>
<h2 id="idea插件"><a href="#idea插件" class="headerlink" title="idea插件"></a>idea插件</h2><p>Name|recommend<br>|:-:| :-: |<br>lombak|自动生成getset等代码</p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2018-11-29T16:00:00.000Z"><a href="/Blog/2018/11/30/try-with-resources/">2018-11-30</a></time>
      
      
  
    <h1 class="title"><a href="/Blog/2018/11/30/try-with-resources/">try-with-resources</a></h1>
  

    </header>
    <div class="entry">
      
        <h2 id="自动关闭资源"><a href="#自动关闭资源" class="headerlink" title="自动关闭资源"></a>自动关闭资源</h2><ul>
<li>Java 7增强了try语句的功能</li>
<li>允许在try关键字后跟一对圆括号，圆括号可以声明，初始化一个或多个资源，此处的资源指得是那些必须在程序结束时必须关闭的资源（比如数据库连接，网络连接等）</li>
<li>try语句在该语句结束时自动关闭这些资源</li>
<li>这些资源实现类必须实现Closeable或AutoCloseable接口，实现这些类就必须实现close方法。</li>
</ul>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code>public class TryWithResource {
    public static void main(String[] args) throws IOException {
        try (
            // 声明、初始化两个可关闭的资源
            // try语句会自动关闭这两个资源。
            BufferedReader br = new BufferedReader(new FileReader(&quot;TryWithResource.java&quot;));
            PrintStream ps = new PrintStream(new FileOutputStream(&quot;a.txt&quot;))) {
            // 使用两个资源
            System.out.println(br.readLine());
            ps.println(&quot;输出资源&quot;);
        }
    }
}
</code></pre>
      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2018-11-29T16:00:00.000Z"><a href="/Blog/2018/11/30/lombok/">2018-11-30</a></time>
      
      
  
    <h1 class="title"><a href="/Blog/2018/11/30/lombok/">lombok</a></h1>
  

    </header>
    <div class="entry">
      
        <p>#Lombok</p>
<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><ul>
<li>是一款Java开发插件</li>
<li>通过其定义的一些注解来消除业务工程中冗长和繁琐的代码，尤其对于简单的Java模型对象（POJO）</li>
<li>在代码编译的时候自动生成这些方法，并非在运行时生成。</li>
</ul>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><ul>
<li>Intellij中安装lombok插件</li>
<li>在项目中加入lombok依赖</li>
</ul>
<h3 id="使用规则"><a href="#使用规则" class="headerlink" title="使用规则"></a>使用规则</h3><h4 id="Getter-and-Setter"><a href="#Getter-and-Setter" class="headerlink" title="@Getter and @Setter"></a>@Getter and @Setter</h4><ul>
<li>注释在类或字段上，自动生成get和set方法<h4 id="ToString"><a href="#ToString" class="headerlink" title="@ToString"></a>@ToString</h4></li>
<li>生成toString()方法，默认情况下，它会按顺序（以逗号分隔）打印你的类名称以及每个字段。可以这样设置不包含哪些字段@ToString(exclude = “id”) <h4 id="NoArgsConstructor"><a href="#NoArgsConstructor" class="headerlink" title="@NoArgsConstructor"></a>@NoArgsConstructor</h4></li>
<li>@NoArgsConstructor生成一个无参构造器</li>
<li>可用@NoArgsConstructor(force = true)，然后就会为没有初始化的final字段设置默认值 0 / false / null。<h4 id="AllArgsConstructor"><a href="#AllArgsConstructor" class="headerlink" title="@AllArgsConstructor"></a>@AllArgsConstructor</h4></li>
<li>生成一个全参数的构造方法<h4 id="Data"><a href="#Data" class="headerlink" title="@Data"></a>@Data</h4></li>
<li>@Data 包含了 @ToString、@EqualsAndHashCode、@Getter / @Setter和@RequiredArgsConstructor的功能</li>
</ul>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2018-11-28T16:00:00.000Z"><a href="/Blog/2018/11/29/拦截器/">2018-11-29</a></time>
      
      
  
    <h1 class="title"><a href="/Blog/2018/11/29/拦截器/">拦截器</a></h1>
  

    </header>
    <div class="entry">
      
        <h2 id="新建类实现HandlerInterceptor或者继承HandlerInterceptorAdapter"><a href="#新建类实现HandlerInterceptor或者继承HandlerInterceptorAdapter" class="headerlink" title="新建类实现HandlerInterceptor或者继承HandlerInterceptorAdapter"></a>新建类实现HandlerInterceptor或者继承HandlerInterceptorAdapter</h2><pre><code>public class SessionInterceptor extends HandlerInterceptorAdapter {
    //spring-mvc配置文件中增加此类

    @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler)
            throws Exception {
        System.out.println(&quot;preHandle&quot;);
        return super.preHandle(request, response, handler);
    }

    @Override public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler,
            ModelAndView modelAndView) throws Exception {
        System.out.println(&quot;postHandle&quot;);
        super.postHandle(request, response, handler, modelAndView);
    }

    @Override public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler,
            Exception ex) throws Exception {
        System.out.println(&quot;afterCompletion&quot;);
        super.afterCompletion(request, response, handler, ex);
    }
}
</code></pre><h2 id="在springmvc配置文件中增加此类"><a href="#在springmvc配置文件中增加此类" class="headerlink" title="在springmvc配置文件中增加此类"></a>在springmvc配置文件中增加此类</h2><pre><code>&lt;mvc:interceptors&gt;
    &lt;mvc:interceptor&gt;
        &lt;mvc:mapping path=&quot;/**&quot;/&gt;
        &lt;mvc:exclude-mapping path=&quot;/login&quot;/&gt;
        &lt;bean class=&quot;joseph.study.springmvc.interceptors.SessionInterceptor&quot;/&gt;
    &lt;/mvc:interceptor&gt;
&lt;/mvc:interceptors&gt;
</code></pre>
      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2018-11-28T16:00:00.000Z"><a href="/Blog/2018/11/29/数据摘要算法/">2018-11-29</a></time>
      
      
  
    <h1 class="title"><a href="/Blog/2018/11/29/数据摘要算法/">数据摘要算法</a></h1>
  

    </header>
    <div class="entry">
      
        <h2 id="数据摘要算法简介"><a href="#数据摘要算法简介" class="headerlink" title="数据摘要算法简介"></a>数据摘要算法简介</h2><ul>
<li>数据摘要算法也被称为哈希（Hash）算法或散列算法。</li>
<li>把任意长度的输入，通过散列算法，变换成固定长度的输出，该输出就是散列值。</li>
<li>是一种压缩映射，即散列值的空间通常远小于输入的空间，不同的输入可能会散列成相同的输出，而不可能从散列值来唯一的确定输入值。</li>
<li>是一种将任意长度的消息压缩到某一固定长度的消息摘要的函数。</li>
<li>MD5 和 SHA1 可以说是目前应用最广泛的Hash算法，是以 MD4 为基础设计的。</li>
</ul>
<h3 id="CRC8-CRC16-CRC32"><a href="#CRC8-CRC16-CRC32" class="headerlink" title="CRC8,CRC16,CRC32"></a>CRC8,CRC16,CRC32</h3><ul>
<li>循环冗余校验</li>
<li>CRC32是通讯领域最多的算法</li>
<li>严格的来说，CRC更应该被称为数据校验算法，但其功能与数据摘要算法类似</li>
<li>在 WinRAR、WinZIP 等软件中，也是以 CRC32 作为文件校验算法的。</li>
</ul>
<h4 id=""><a href="#" class="headerlink" title=" "></a> </h4><pre><code>public static long crc32(String data) {
    java.util.zip.CRC32 crc = new java.util.zip.CRC32();
    crc.update(data.getBytes());
    return crc.getValue();
}
</code></pre>
      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2018-11-28T16:00:00.000Z"><a href="/Blog/2018/11/29/@Slf4j/">2018-11-29</a></time>
      
      
  
    <h1 class="title"><a href="/Blog/2018/11/29/@Slf4j/">slf4j注解简化日志代码</a></h1>
  

    </header>
    <div class="entry">
      
        <h3 id="pom中添加依赖"><a href="#pom中添加依赖" class="headerlink" title="pom中添加依赖"></a>pom中添加依赖</h3><pre><code>&lt;dependency&gt;
   &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;
   &lt;artifactId&gt;lombok&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre><h3 id="在类上添加-Slf4j注解"><a href="#在类上添加-Slf4j注解" class="headerlink" title="在类上添加@Slf4j注解"></a>在类上添加@Slf4j注解</h3><pre><code>@Slf4j
public class Test {
}    
</code></pre><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><ul>
<li>类中不需要写private  final Logger logger = LoggerFactory.getLogger(XXX.class);</li>
</ul>
<h3 id="直接在代码中使用log"><a href="#直接在代码中使用log" class="headerlink" title="直接在代码中使用log"></a>直接在代码中使用log</h3><pre><code>log.debug(&quot;debug message&quot;);
log.warn(&quot;warn message&quot;);
log.info(&quot;info message&quot;);
log.error(&quot;error message&quot;);
log.trace(&quot;trace message&quot;);
</code></pre><h3 id="如果注解-Slf4j注入后找不到变量log，需要安装lombok插件"><a href="#如果注解-Slf4j注入后找不到变量log，需要安装lombok插件" class="headerlink" title="如果注解@Slf4j注入后找不到变量log，需要安装lombok插件"></a>如果注解@Slf4j注入后找不到变量log，需要安装lombok插件</h3>
      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2018-11-26T16:00:00.000Z"><a href="/Blog/2018/11/27/logback/">2018-11-27</a></time>
      
      
  
    <h1 class="title"><a href="/Blog/2018/11/27/logback/">logback</a></h1>
  

    </header>
    <div class="entry">
      
        <h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ul>
<li>logback是由log4j创始人设计的又一个开源日志组件</li>
<li>logback当前分成三个模块：logback-core,logback-classic和logback-access</li>
<li>logback-core是其它两个模块的基础模块</li>
<li>logback-classic是log4j的一个改良版本</li>
<li>logback-classic完整实现SLF4J API使你可以很方便地更换成其它日志系统如log4j或JDK14 Logging</li>
<li>logback-access访问模块与Servlet容器集成提供通过Http来访问日志的功能(用的少)</li>
<li>logback-classic和logback-access已经依赖logback-core,不需要单独引用</li>
</ul>
<h2 id="maven依赖"><a href="#maven依赖" class="headerlink" title="maven依赖"></a>maven依赖</h2><h4 id=""><a href="#" class="headerlink" title=""></a><dependencies></dependencies></h4><pre><code>    &lt;!--logback start--&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.slf4j&lt;/groupId&gt;
        &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt;
        &lt;version&gt;1.7.21&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt;
        &lt;artifactId&gt;logback-classic&lt;/artifactId&gt;
        &lt;version&gt;1.1.7&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt;
        &lt;artifactId&gt;logback-access&lt;/artifactId&gt;
        &lt;version&gt;1.1.7&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;!--logback end --&gt;
&lt;/dependencies&gt;
</code></pre><h2 id="常用配置文件配置"><a href="#常用配置文件配置" class="headerlink" title="常用配置文件配置"></a>常用配置文件配置</h2><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;configuration scan=&quot;true&quot; scanPeriod=&quot;60 seconds&quot; debug=&quot;true&quot;&gt;
    &lt;!-- 从高到地低 OFF 、 FATAL 、 ERROR 、 WARN 、 INFO 、 DEBUG 、 TRACE 、 ALL --&gt;
    &lt;!--
         scan：性设置为true时，配置文件如果发生改变，将会被重新加载，默认值为true
         scanPeriod:设置监测配置文件是否有修改的时间间隔，如果没有给出时间单位，默认单位是毫秒。当scan为true时，此属性生效。默认的时间间隔为1分钟
         debug:当此属性设置为true时，将打印出logback内部日志信息，实时查看logback运行状态。默认值为false
    --&gt;
    &lt;!--设置日志上下文名称，后面输出格式中可以通过定义 %contextName 来打印日志上下文名称--&gt;
    &lt;contextName&gt;logback&lt;/contextName&gt;
    &lt;!-- 定义日志文件 输入位置 --&gt;
    &lt;property name=&quot;log_dir&quot; value=&quot;E:/studylogs&quot; /&gt;
    &lt;!-- 日志最大的历史 30天 --&gt;
    &lt;property name=&quot;maxHistory&quot; value=&quot;30&quot; /&gt;

    &lt;!-- ConsoleAppender 控制台输出日志 --&gt;
    &lt;appender name=&quot;stdout&quot; class=&quot;ch.qos.logback.core.ConsoleAppender&quot;&gt;
        &lt;!--过滤掉所有低于info级别的日志。 --&gt;
        &lt;filter class=&quot;ch.qos.logback.classic.filter.ThresholdFilter&quot;&gt;
            &lt;level&gt;info&lt;/level&gt;
        &lt;/filter&gt;
        &lt;!-- 对日志进行格式化 --&gt;
        &lt;encoder&gt;
            &lt;pattern&gt;%d{yyyy-MM-dd HH:mm:ss} [%thread] %-5level %logger -%msg%n
            &lt;/pattern&gt;
            &lt;charset&gt;UTF-8&lt;/charset&gt; &lt;!-- 此处设置字符集 --&gt;
        &lt;/encoder&gt;
    &lt;/appender&gt;

    &lt;!-- DEBUG级别日志 appender --&gt;
    &lt;appender name=&quot;debug&quot;
              class=&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;&gt;
        &lt;!-- 过滤器，只记录info级别的日志 --&gt;
        &lt;filter class=&quot;ch.qos.logback.classic.filter.LevelFilter&quot;&gt;
            &lt;level&gt;info&lt;/level&gt;
            &lt;onMatch&gt;ACCEPT&lt;/onMatch&gt;
            &lt;onMismatch&gt;DENY&lt;/onMismatch&gt;
        &lt;/filter&gt;
        &lt;rollingPolicy class=&quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&quot;&gt;
            &lt;!-- 按天回滚 daily --&gt;
            &lt;fileNamePattern&gt;${log_dir}/%d{yyyy-MM-dd}/debug-log.log
            &lt;/fileNamePattern&gt;
            &lt;!-- 日志最大的历史 60天 --&gt;
            &lt;maxHistory&gt;${maxHistory}&lt;/maxHistory&gt;
        &lt;/rollingPolicy&gt;
        &lt;encoder&gt;
            &lt;pattern&gt;%d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level %logger -
                %msg%n&lt;/pattern&gt;
            &lt;charset&gt;UTF-8&lt;/charset&gt; &lt;!-- 此处设置字符集 --&gt;
        &lt;/encoder&gt;
    &lt;/appender&gt;

    &lt;!-- ERROR级别日志 --&gt;
    &lt;!-- 滚动记录文件，先将日志记录到指定文件，当符合某个条件时，将日志记录到其他文件 RollingFileAppender --&gt;
    &lt;appender name=&quot;ERROR&quot;
              class=&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;&gt;
        &lt;!-- 过滤器，只记录WARN级别的日志 --&gt;
        &lt;filter class=&quot;ch.qos.logback.classic.filter.LevelFilter&quot;&gt;
            &lt;level&gt;ERROR&lt;/level&gt;
            &lt;onMatch&gt;ACCEPT&lt;/onMatch&gt;
            &lt;onMismatch&gt;DENY&lt;/onMismatch&gt;
        &lt;/filter&gt;
        &lt;!-- 最常用的滚动策略，它根据时间来制定滚动策略.既负责滚动也负责出发滚动 --&gt;
        &lt;rollingPolicy class=&quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&quot;&gt;
            &lt;!--日志输出位置 可相对、和绝对路径 --&gt;
            &lt;fileNamePattern&gt;${log_dir}/%d{yyyy-MM-dd}/error-log.log
            &lt;/fileNamePattern&gt;
            &lt;!-- 可选节点，控制保留的归档文件的最大数量，超出数量就删除旧文件假设设置每个月滚动，且&lt;maxHistory&gt;是6， 则只保存最近6个月的文件，删除之前的旧文件。注意，删除旧文件是，那些为了归档而创建的目录也会被删除 --&gt;
            &lt;maxHistory&gt;${maxHistory}&lt;/maxHistory&gt;
        &lt;/rollingPolicy&gt;
        &lt;encoder&gt;
            &lt;pattern&gt;%d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level %logger -
                %msg%n&lt;/pattern&gt;
            &lt;charset&gt;UTF-8&lt;/charset&gt; &lt;!-- 此处设置字符集 --&gt;
        &lt;/encoder&gt;
    &lt;/appender&gt;

    &lt;!-- root级别 DEBUG --&gt;
    &lt;root level=&quot;debug&quot;&gt;
        &lt;!--定义了两个appender，日志会通过往这两个appender里面写--&gt;
        &lt;appender-ref ref=&quot;stdout&quot;/&gt;
        &lt;appender-ref ref=&quot;debug&quot;/&gt;
    &lt;/root&gt;

    &lt;!--这个logger没有指定appender，它会继承root节点中定义的那些appender--&gt;
    &lt;logger name=&quot;joseph.study.Logback&quot; level=&quot;info&quot;/&gt;

    &lt;!--通过 LoggerFactory.getLogger(&quot;mytest&quot;) 可以获取到这个logger--&gt;
    &lt;!--由于这个logger自动继承了root的appender，root中已经有stdout的appender了，自己这边又引入了stdout的appender--&gt;
    &lt;!--如果没有设置 additivity=&quot;false&quot; ,就会导致一条日志在控制台输出两次的情况--&gt;
    &lt;!--additivity表示要不要使用rootLogger配置的appender进行输出--&gt;
    &lt;logger name=&quot;mytest&quot; level=&quot;DEBUG&quot; additivity=&quot;false&quot;&gt;
        &lt;appender-ref ref=&quot;stdout&quot;/&gt;
    &lt;/logger&gt;
&lt;/configuration&gt;
</code></pre>
      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>





<nav id="pagination">
  
  
    <a href="/Blog/page/2/" class="alignright next">Next</a>
  
  <div class="clearfix"></div>
</nav></div></div>
    <aside id="sidebar" class="alignright">
  <div class="search">
  <form action="//google.com/search" method="get" accept-charset="utf-8">
    <input type="search" name="q" results="0" placeholder="Search">
    <input type="hidden" name="q" value="site:josephagk.github.io">
  </form>
</div>

  
<div class="widget tag">
  <h3 class="title">Categories</h3>
  <ul class="entry">
  
    <li><a href="/Blog/categories/concurrent/">concurrent</a><small>1</small></li>
  
    <li><a href="/Blog/categories/idea/">idea</a><small>3</small></li>
  
    <li><a href="/Blog/categories/java-ee/">java ee</a><small>1</small></li>
  
    <li><a href="/Blog/categories/java-se/">java se</a><small>3</small></li>
  
    <li><a href="/Blog/categories/mysql/">mysql</a><small>2</small></li>
  
    <li><a href="/Blog/categories/springmvc/">springmvc</a><small>1</small></li>
  
    <li><a href="/Blog/categories/前端/">前端</a><small>3</small></li>
  
    <li><a href="/Blog/categories/加密/">加密</a><small>1</small></li>
  
    <li><a href="/Blog/categories/工农工具/">工农工具</a><small>1</small></li>
  
    <li><a href="/Blog/categories/日志/">日志</a><small>2</small></li>
  
  </ul>
</div>




  
<div class="widget tag">
  <h3 class="title">Tags</h3>
  <ul class="entry">
  
    <li><a href="/Blog/tags/Interceptor/">Interceptor</a><small>1</small></li>
  
    <li><a href="/Blog/tags/class/">class</a><small>3</small></li>
  
    <li><a href="/Blog/tags/email/">email</a><small>1</small></li>
  
    <li><a href="/Blog/tags/hash/">hash</a><small>1</small></li>
  
    <li><a href="/Blog/tags/idea/">idea</a><small>2</small></li>
  
    <li><a href="/Blog/tags/logback/">logback</a><small>1</small></li>
  
    <li><a href="/Blog/tags/select2冲突/">select2冲突</a><small>1</small></li>
  
    <li><a href="/Blog/tags/software/">software</a><small>1</small></li>
  
    <li><a href="/Blog/tags/sql/">sql</a><small>2</small></li>
  
  </ul>
</div>

</aside>
    <div class="clearfix"></div>
  </div>
  <footer id="footer" class="inner"><div class="alignleft">
  
  &copy; 2018 JosephGK
  
</div>

<div class="clearfix"></div></footer>
  <script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>
<script src="/Blog/js/jquery.imagesloaded.min.js"></script>
<script src="/Blog/js/gallery.js"></script>




<link rel="stylesheet" href="/Blog/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/Blog/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
  $('.fancybox').fancybox();
})(jQuery);
</script>

</body>
</html>
